{"version":3,"sources":["Game/images/tiles sync /^/.//.*/.png$","Game/images/brick.png","Game/images/goomba.png","Game/images/goombared.png","Game/images/no-image.png","Game/images/player.png","Game/images/questionbrick.png","Game/images/spike.png","Code/reducer.js","Game/constants.js","util/state.js","util/parse.js","Game/physics.js","Game/reducer.js","SpriteEditor/reducer.js","reducers.js","debug/DebugColliding.js","Game/Sprite.js","Game/Game.js","Game/Loop.js","Game/actions.js","Code/actions.js","ImagePicker/ImagePicker.js","Code/Code.js","SpriteEditor/Tile.js","SpriteEditor/SpriteEditor.js","Examples/exampleCode.js","Examples/ExamplesModal.js","App/App.js","App/actions.js","index.js","Game/images sync /^/.//.*/.png$","Game/images/tiles/tile0.png","Game/images/tiles/tile1.png","Game/images/tiles/tile2.png","Game/images/tiles/tile3.png"],"names":["map","./tile0.png","./tile1.png","./tile2.png","./tile3.png","webpackContext","req","id","webpackContextResolve","__webpack_require__","e","Error","code","keys","Object","resolve","module","exports","defaultState","gameReducer","state","arguments","length","undefined","action","type","objectSpread","TOP","LEFT","RIGHT","createNewSprite","name","x","y","position","prevPosition","velocity","maxVelocity","acceleration","colliding","top","bottom","left","right","static","inputs","separateWords","leftAndRightString","string","replace","trimBrackets","trim","split","states","UP","DOWN","FAST_UP","FAST_DOWN","FAST_LEFT","FAST_RIGHT","SLOW_UP","SLOW_DOWN","SLOW_LEFT","SLOW_RIGHT","JUMP","DEAD","dead","STATIC","<UP>","<DOWN>","<LEFT>","<RIGHT>","<ACTION>","<ACTION1>","<ACTION2>","getCollidingForSide","side","traverseDirection","currentIndex","nextIndex","collidesWith","console","error","nextColliding","defineProperty","getColliding","direction","leftStates","leftIndex","frontSide","down","up","directionToSide","backSide","forward","getOpposite","frontColliding","backColliding","wordsToState","words","names","statesArr","word","resultState","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","Symbol","iterator","next","done","stateObj","value","merge","err","return","addNewState","sprites","newState","toConsumableArray","concat","mergeCustomizer","objValue","srcValue","isNumber","applyStateMutations","sprite","mutations","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","mutation","_mutation2","slicedToArray","matches","mergeWith","isAlive","isCreateNewState","stateMutation","createNew","isCollisionRule","line","includes","isRule","isLevel","match","isLegend","expansionMappings","ALL","HORIZONTAL","VERTICAL","isExpandable","_arr","_i","key","replaceWord","newWord","newLine","expandRule","lines","_arr2","entries","_i2","_ref3","_ref2","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","push","expandRules","alreadyExpanded","filter","freshlyExpanded","flatten","addImplicitKeywords","_line$split3","appendedLine","roundToPixels","Math","round","getEdges","isOverlapping","spriteA","spriteB","a","b","overlapsPoint","point","padding","_getEdges","overlapsSide","points","getPointsForSide","getCollidedEdges","prevEdgesA","prevEdgesB","collidedEdges","getSeparatedState","edgeA","edgesB","applySpriteCollisions","newSpriteA","storePreviousPosition","applyAcceleration","max","min","applyVelocity","resetColliding","applyFriction","legend","rules","stateMutations","width_in_tiles","height_in_tiles","active","theme","debug","imageMap","images","_sprites","_sprites2","_sprites3","_sprites4","_sprites5","_sprites6","_sprites7","_sprites8","_sprites9","_sprites10","_sprites11","_sprites12","_sprites13","_sprites14","variableName","imageName","join","removeComments","level","slice","parseLevel","forEach","_line$split$map","str","_line$split$map2","symbol","randIndex","floor","random","parseLegend","row","char","col","getName","uniqid","parseSprites","namesArr","_line$split","parseNames","reduce","obj","item","toLowerCase","_parseRules","regularRules","collisionRules","parseRules","_parseRules2","rule","ruleString","_ruleString$split3","_ref","leftWords","rightWords","ruleToStateMutation","collisionStateMutationPairs","_leftGroup$split","_rightGroup$split","_ruleString$match","_ruleString$split","_ruleString$split2","_left$match","leftGroup","_right$match","rightGroup","leftWordArrays","rightWordArrays","rightStates","leftStatesWithColliding","index","rightIndex","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","matchingLeft","newSprite","leftState","collisionRuleToStateMutations","collisionStateMutations","collisionStateMutationsCreate","collisionStateMutationsModify","_getLevelDimensions","getLevelDimensions","_getLevelDimensions2","width","height","stateToAdd","vectorA","vectorB","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_mutation","getNewStateToAdd","edge","collidingSprite","updateSpriteCollidingState","newPosition","applyWallCollisions","input","newInputs","initialTileSets","tileImages","rasterise","tileSet","canvas","document","createElement","ctx","getContext","rowIndex","colIndex","tileImage","image","Image","onload","log","drawImage","src","toDataURL","tileSets","open","spriteEditorReducer","combineReducers","codeReducer","game","spriteEditor","DebugColliding","react_default","className","getPositionStyle","Sprite","img","style","require","alt","DebugColliding_DebugColliding","Game","src_Game_Sprite","connect","dispatch","onTimeChange","request","useEffect","requestAnimationFrame","advanceFrame","cancelAnimationFrame","compile","onSelect","Tooltip_default","interactive","title","onClick","grammar","comment","variable","pattern","RegExp","onKeyDown","event","editor","ctrlKey","preventDefault","addMark","getContent","token","content","decorateNode","node","others","texts","getTexts","toArray","t","text","tokens","Prism","tokenize","decorations","startText","shift","endText","startOffset","endOffset","start","newlines","end","available","remaining","dec","anchor","offset","focus","mark","onUpdateCode","Plain","serialize","onCompile","slate_react_es","defaultValue","deserialize","onChange","renderMark","props","children","attributes","_node$text$split$map","_right$split","firstName","src_ImagePicker_ImagePicker","assign","opacity","fontWeight","Tile","SpritePicker","selectedTileSet","Preview","tiles","selectedTile","rowArr","tileIndex","src_SpriteEditor_Tile","TilePicker","_ref5","updateTileSets","_ref4","onClose","_useState","useState","_useState2","setSelectedTileSet","_useState3","_useState4","setSelectedTile","Dialog_default","SpriteEditor_SpritePicker","SpriteEditor_Preview","newTileIndex","newTileSets","SpriteEditor_TilePicker","examples","simple_movement","simple_platformer","four_way_movement","loadPreset","visible","setVisible","stopPropagation","react","react_textarea_autosize_esm_browser","darkColors","primary","secondary","dark","light","lightColors","keyMap","sequence","action1","action2","cancel_up","cancel_down","cancel_left","cancel_right","cancel_action1","cancel_action2","handlers","onSetInput","onCancelInput","onReset","onRun","onToggleDebug","isGameActive","r","d","space","setGameActive","setActive","setInput","cancelInput","onToggleTheme","onToggleExamples","onOpenCloseSpriteEditor","colors","react_custom_properties_default","properties","--primary-color","--secondary-color","--dark-color","--light-color","--hover-color","Examples_ExamplesModal","src_Code_Code","index_es","Game_Loop","src_SpriteEditor_SpriteEditor","src_Game_Game","persistConfig","storage","persistedReducer","persistReducer","rootReducers","store","createStore","window","__REDUX_DEVTOOLS_EXTENSION__","persistor","persistStore","purge","ReactDOM","render","es","integration_react","loading","src_App_App","getElementById","./brick.png","./goomba.png","./goombared.png","./no-image.png","./player.png","./questionbrick.png","./spike.png","./tiles/tile0.png","./tiles/tile1.png","./tiles/tile2.png","./tiles/tile3.png"],"mappings":"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","file":"static/js/main.8915a85d.chunk.js","sourcesContent":["var map = {\n\t\"./tile0.png\": 94,\n\t\"./tile1.png\": 95,\n\t\"./tile2.png\": 96,\n\t\"./tile3.png\": 97\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 136;","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAD5JREFUWAnt10ERADAIA7Ax87iZRXao6CcYaMmv1fPmJC9ZYLNv8vnNVoAAAQIECBAgQIAAAQIECFRyHe84/XTlDQmQUCOUAAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAYdJREFUWAntVz1LA0EQfbuEeAgi2EWsBCsL/0JqKytLf4KV+IGQIiDxxMqfYBOwECvr/AULK8FKSCeIzWlx6zzjQdibDRdwL80NhNy8zMx7O3N3YQzEUve4kePrCnBdcTvEItoYMCOLpeMTs/tmSO6QPTlgLSJpqbQB3g2Sndbk5PWSUw0P7KTr9q/tJYX1AK4rAqLPfNZZOhSwUGsENB1oOhDqwDdgTxMsr/PDa3lWBatslfNbeknbOzN76dRv6cA9iJtfTmEzLqvnqx1IkNz61TXMjyl8LVbDGK8KKArV8a0KyJAd+OQa5scUvharYYw3A3cv/4wl403UK9o2Sc77EtUuRepA5fyQAL1sBFQdQQSeYMlGQOBFJHcn7Pkmtq73zfY8b0C11Xfuuf2KlyOH/MIPCI5gBas3/0FOQtZhPZ+cflDAJz4OqVxLmhdjHdbT8prHMDgCrV0xMAqQXW1hNhYBZrQwei6p3FK5KNYtgpzktr8rsmyp0omhiKhjHMJhhtyMyf0DfCpzwbzHSMoAAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAYxJREFUWAntV0FKw1AQnT82WRQqtDvFdbdewVN06RFciRUCLiwFI648QjdCT+EV3HYtuEvRgosEE+dFAk2Y3ybgTzcZKM1M3rw3mUk+/xsS+w7DsyRJHg3RRZZlJ4i5MmPMR0b06nneTX86fTe5eBy/ieDIlaiFN/J8/5zx5AcQR00jaDPaDu8QBm12PfNdDwZt3gVo415XQNeBrgNqB2SBiA3zbY/5FD9cI1b3s2yS31NJme+OgyDcuhd+zedEafqwFbNfNshXO3BEtKiya7EqpvA1rBYDXi2gIGrjXy3gh+iyKq7FqpjC17BaDHjzOZvJ/qBs+Qsncyzalien6b0A/TJS95rkqwXotG6i6gjcSOmsXQH6QiTdkt1rMBiPn8xkUnsF1JtMlC2X/ma1upYdkKxmZbOOYDAcPv+HOOTAA76y9J9nLWCzXl+hci2paSzvgPBped1naB2B1i4XMcZZzQVxHU5oMw6KdcAuMNBmnFKFPHIhsIczgjbjiIxTqqw8L22MI9cQLWhC+xfEpII8G45emQAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAW5JREFUWAntlsFOwzAMhu1qrwMSnOAtYOLCk3SDM6IVD8IFTeMp2AleqJqxS5JtrsucCSlCai6J7dj/lyxWh8+0Iig5SgKIdlXy8KI9AUw38P9uoKH12W+dcyyuc7NuoKX1HQF9cv82upDY4pe47LPils8NIEW3QK8ANONCtYYIdi1x2eeFcAEo8XiQBLETjyE/hAuAT3QZTh4V4iwQH2zwyfWgGcH2Qnu17QJY4u0DJ7Y6OdhXI/52gfPHkVhyuwBk9xLnC57GIFLBsGjDfu0f2G4AyXRCuMWlZhaAJPz1yAIYvnYTJ3WHGVVON4BTPJZ3Q7gAGlo9cWWj1Xq9TVRVcx3ylPvQdAEgVF8A2B2m9pY8uGteGd2B3U+ekbXncgHUePNWAd4riPTah92BneyXvD0tc+kCkEwFkcRj1R2EX7zP5ceV9bf8hd7Po6g153yOe+1cAEv0VJ9ou3+CU0WO5U0A0w0UvwEs2YbSId8ezJqOYuBQ4gAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAU5JREFUWAljZCAA2v+v+09ACU5pRgbG/xWMgUw4FQAl8Eri00gtuVEHjIbAaAgMeAgwUlLQUKMsGPAQGHXAaAjgDAFgVTodhClN6YTMwZkNKxmDGEGWU5JNkdsDuMzBGQKU+pxY/SyEFMJCgpA6cuUJhgAw6Cb+//8fHB2kWALS0/F/fSchPQQdADQgr5Nhw2yggcSoBdu3//9+FqCeeUBOKTUcwPCf4X9yJ8P6pSCDCRnY9/8Y50mGD8CW7P8EQmpB8gSDFi31buJm4AjLY/T6ic3w/v/rBX4wMGxiYPhvCzGc+q1iv68MP7fM/L+ZC90B/f93SP5g+H8QZjlIHhgKBD1IdLwiLPzv8p7hz87e/xtkYWLd/zfq/WT4fhTI14OJEUsTjFNsBgF9ZvOL4f8joBzYh38Y/l7Epo4YMTJCgBhjiVcz6oDREBjwEAAAwOJpSUqjPhYAAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAX5JREFUWAlj/Njc/J9hIMFAOgBkN9NAeh5k96gDRkNgNARYKMmGXzs7pf78/i3HxsDwnLOm5iE5ZpHlgM9tbaL//v1b9OfXLw+Qpb+A+FNLyz5eLq5QxqKid6Q4hKw0ALR8McP//2DLGRgZ7zEyMv79//+/0+evXyeSYjlILckO+N/fLwDUpwXEX4AWJ/DX1Cj/Z2QsBRkGpO1BNCmA5ChgLCz8ALRADmYJ0OeMn1ta7EA1GuP//49g4sTSJDsA2WCw5a2tM4CWB4CiAYhrkeWJYZMcBciGfm5tLQY6Ig1sOQNDOG919X5keWLYFDkA6HN3kCVAejZvTc1aYixEV0NRFDAyMTUBDZzKwMx8Hd1gYvmUhcD//4oMf/+mMv/7x0WshejqKAoBYFkwDRj83H///AGVRYHohhPDpygEGBkY9gATIDD7M+4lxjKsaihtE/6fOZPs4KdKm5AxPf0bVp8RKUhRFBBpB15low4YDYHREBjwEGCktCTEm8mJkAQABD53sd5+Ls8AAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAhVJREFUWAm9lulOwkAUhaf1WXCNStwIavzhGmOMxrihj+JSTFqsPgpv4Wv4Fmw/JHSuR5Lb2NJhpqWUhEw7c++Z75wuIMQEn9bnZ6nruo8TSAh7kmbr5+dVEjnUbM5k1ckM0G40ZoVl1UiIUvv7+6FwAAoCh4iGzi2iJxxnMpOpCe7nLSHu2TVSmOt5Xo3P04yZAIbuRfT+kUI8Z0khNUDn42MB7m/jLrH5PFK4i8/rzlMDyH6/jsgT+7KkkCikou74/hLcX6vWkcJi1/NuVOtJ86kAaDBwVO5ZHBAv+ILT7GMM0PX9ZUgq3fN2AFxCCto6rjcGkH/uDZ2lScEIAI5WQHzF1LoRKSyjx6jeCADv+7qpe4YzTUELACdliF6ysOmIFFY7nqft0wJkcc+QgHjlY9U4FgBvtjVEeaFq1s4TlduuO7Z/LECAa6/dRFOgS0EJ0Ht/X4f7c42+fploDSkodZQAQRC86dXNKsalkAgA95twf2Ymb1BFtNHyvES9RIA83Yd4RIlPxAhAq9GowP1p2JjXAdEWUhjRHQEQUuZ27ePslpROfC4CgP96VUF0Ei/K6xw3YwVv1oh+BICkrOe1mUpHxlIIAfCsbsP9saoxr3mkUEUKR6wXAmBhateeN+PxfwpDALjfhftDLpj2CLM7SOHgbx9OoDD3bI5TsDquu4ef3C9eKHK0bXvfLvLax83hqXN+AWhR9c/gEiSNAAAAAElFTkSuQmCC\"","\nconst initialCode = `\n##################\n#                #\n#                #\n#                #\n#                #\n#                #\n#                #\n#    P           #\n#             G  #\n##################\n\nP = Player\n# = Brick\n? = QuestionBrick or Brick\nG = Goomba\nR = GoombaRed\n^ = Spike\n\n[ <HORIZONTAL> Player ] -> [ HORIZONTAL Player ]\n[ <UP> Player | Wall ] -> [ JUMP Player | Wall ]\n[ <ACTION> Player | Wall ] -> [ JUMP Player | Wall ]\n[ Player ] -> [ DOWN Player ]\n[ Goomba ] -> [ DOWN Goomba ]\n\nHORIZONTAL [ Player | Goomba ] -> [ DEAD Player | Goomba ]\nDOWN [ Player | Goomba ] -> [ Player | DEAD Goomba ]\n`;\n\nconst defaultState = {\n  code: initialCode\n}\n\nconst gameReducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'UPDATE_CODE':\n      return {...state, code: action.code}\n    default:\n      return state\n  }\n}\n\nexport default gameReducer","\nexport const TILE_SIZE = 32;\nexport const GROUND_FRICTION = 0.85;\nexport const AIR_FRICTION = 0.85;\nexport const MAX_VELOCITY = 20;\nexport const TOP = 'top';\nexport const BOTTOM = 'bottom';\nexport const LEFT = 'left';\nexport const RIGHT = 'right';","import uniqid from 'uniqid';\nimport {matches, mergeWith, merge, isNumber} from 'lodash';\nimport {MAX_VELOCITY, TILE_SIZE} from '../Game/constants.js';\n\nexport const createNewSprite = (name, x, y)=> ({\n  name: name,\n  position: {x, y},\n  prevPosition: {x, y},\n  velocity: {x: 0, y: 0},\n  maxVelocity: {x: MAX_VELOCITY, y: MAX_VELOCITY},\n  acceleration: {x: 0, y: 0},\n  colliding: {\n    top: [],\n    bottom: [],\n    left: [],\n    right: []\n  },\n  static: false,\n  inputs: {}\n});\nconst trimBrackets = (string)=> string.replace('[', '').replace(']', '')\nconst separateWords = (leftAndRightString)=> (\n  leftAndRightString.map((string)=>\n    trimBrackets(string).trim().split(' ')\n  )\n);\nconst states = {\n  UP: {acceleration: {y: -1}},\n  DOWN: {acceleration: {y: 1}},\n  LEFT: {acceleration: {x: -1}},\n  RIGHT: {acceleration: {x: 1}},\n  FAST_UP: {acceleration: {y: -6}},\n  FAST_DOWN: {acceleration: {y: 6}},\n  FAST_LEFT: {acceleration: {x: -6}},\n  FAST_RIGHT: {acceleration: {x: 6}},\n  SLOW_UP: {acceleration: {y: -0.5}},\n  SLOW_DOWN: {acceleration: {y: 0.5}},\n  SLOW_LEFT: {acceleration: {x: -0.5}},\n  SLOW_RIGHT: {acceleration: {x: 0.5}},\n  JUMP: {velocity: {y: -150}},\n  DEAD: {dead: true},\n  STATIC: {static: true}\n};\n\nconst inputs = {\n  '<UP>': 'up',\n  '<DOWN>': 'down',\n  '<LEFT>': 'left',\n  '<RIGHT>': 'right',\n  '<ACTION>': 'action1',\n  '<ACTION1>': 'action1',\n  '<ACTION2>': 'action2'\n};\n\nconst getOpposite = (direction)=> {\n  const oppositeMappings = {\n    'left': 'right',\n    'right': 'left',\n    'top': 'bottom',\n    'bottom': 'top',\n    'up': 'down',\n    'down': 'up',\n    'forward': 'backward'\n  }\n\n  return oppositeMappings[direction];\n}\n\nconst directionToSide = (direction)=> {\n  const mappings = {\n    'left': 'left',\n    'right': 'right',\n    'down': 'bottom',\n    'up': 'top'\n  }\n\n  return mappings[direction];\n}\n\n// Recursively finds the colliding state\nconst getCollidingForSide = (side, traverseDirection, states, currentIndex)=> {\n  const nextIndex = traverseDirection === 'forward' ? currentIndex + 1 : currentIndex - 1;\n  // outside range\n  if (nextIndex < 0 || nextIndex === states.length) {\n    return;\n  }\n\n  const collidesWith = states[nextIndex];\n  if (!collidesWith) {\n    console.error('Expecting there to always be a state here');\n  }\n\n  let state = [{\n    ...collidesWith\n  }];\n\n  const nextColliding = getCollidingForSide(side, traverseDirection, states, nextIndex);\n  if (nextColliding) {\n    state.colliding = {\n      [side]: nextColliding\n    }  \n  }\n\n  return state;\n}\n\nconst getColliding = (direction, leftStates, leftIndex)=> {\n  // direction refers to the direction the collision rule is applied in.\n  // getCollidingForSide('bottom', 'forward' ... refers to searching for the colliding state for\n  // the bottom side by traversing the ruleString to the right (forward)\n  let colliding = {};\n  const frontSide = directionToSide(direction);\n  const backSide = getOpposite(frontSide);\n  const frontColliding = getCollidingForSide(frontSide, 'forward', leftStates, leftIndex);\n  const backColliding = getCollidingForSide(backSide, 'backward', leftStates, leftIndex);\n\n  if (backColliding) {\n    colliding[backSide] = backColliding;\n  }\n\n  if (frontColliding) {\n    colliding[frontSide] = frontColliding;\n  }\n\n  if (frontColliding || backColliding) {\n    return colliding; \n  }\n  else {\n    return;\n  }\n}\n\n/*\nStarts withObject.keys( ).length > 0 ? colliding : undefined;\n  [ UP Player | Spike ] -> [ DEAD Player | Spike ]\nBreaks up into 2 rules\n  [ UP Player] -> [ DEAD Player]\n  [ Spike ] -> [ Spike ]\nEvaluate both rules into a pair of state mutations\n[\n  {name: \"Player\", acceleration: {x: 1, y: 0}},\n  {name: \"Player\", dead: true}\n]\n[\n  {name: \"Spike\"},\n  {name: \"Spike\"}\n]\n// Finally adds a colliding property to the left side each state mutation\n[\n  {\n    name: \"Player\", acceleration: {x: 1, y: 0},\n    colliding: {\n      top: {name:'Spike'}, bottom: {name:'Spike'},\n      left: {name:'Spike'}, right: {name:'Spike'}\n    }\n  },\n  {name: \"Player\", dead: true}\n]\n[\n  {\n    name: \"Spike\",\n    colliding: {\n      top: {name:'Player'}, bottom: {name:'Player'},\n      left: {name:'Player'}, right: {name:'Player'}\n    }\n  }\n  {name: \"Spike\"}\n]\n*/\nexport const collisionRuleToStateMutations = (ruleString, names)=> {\n  // Get collision direction (first word at the start of the line)\n  const [firstWord] = ruleString.match(/^([A-Z]+)\\b/);\n  const direction = firstWord.toLowerCase();\n\n  // Get the left and right matches\n  const [left, right] = ruleString.split('->');\n  const [leftGroup] = left.match(/\\[.+?\\]/);\n  const [rightGroup] = right.match(/\\[.+?\\]/);\n\n  // leftWords and rightWords can each be arbirary lengths\n  // Consider the left side could be a collision involving 3 parties but on the right side\n  // we only care about the first of those parties.\n  // [ Player | Goomba | Player2 ] -> [ | DEAD Goomba | ]\n\n  // Also consider the left side may involve no collisions, but the right side might\n  // as is the case of mario throwing a fireball\n  // HORIZONTAL [ <ACTION> Mario] -> [ Mario | HORIZONTAL Fireball ]\n  // HORIZONTAL [ <ACTION> Mario] -> [ Mario + HORIZONTAL Fireball ]\n  \n  // const min = Math.min(left.length, right.length);\n  // const max = Math.max(left.length, right.length);\n\n  // // Deal with the simple matches first\n  // for (let i = 0; i < min; i++) {\n\n  // }\n\n  // // These are the extras, the ones that don't have a match on the opposite side\n  // for (let i = min; i < max; i++) {\n  //   // If they exist on the left, but not the right. Then it is assumed the sprite is to remain as it was\n  //   if (left.length > right.length) {\n  //     const oldWords = left[i];\n  //   }\n  //   // But if they exist on the right, but not the left. Then these are new sprites to be spawned.\n  //   else {\n  //     const newWords = right[i];\n  //   }\n  // }\n\n  // <-------- leftWordArrays----->    <--- rightWordArrays -->\n  // <---words--> < ----words----->    <-words-> <---words---->\n  // [ UP Player | Goomba | Brick ] -> [ Player | DEAD Goomba ]\n  const leftWordArrays = leftGroup.split('|') |> separateWords;\n  const rightWordArrays = rightGroup.split('|') |> separateWords;\n\n  let leftStates = [];\n  let rightStates = [];\n\n  // Left\n  // The left side is what the rule is looking to match.\n  // The colliding state should recursively nest colliding states if the rule has multiple collisions\n  for (const words of leftWordArrays) {\n    const state = {\n      ...wordsToState(words, names)\n    }\n\n    leftStates.push(state);\n  }\n\n  const leftStatesWithColliding = leftStates.map((state, index)=> {\n    const colliding = getColliding(direction, leftStates, index);\n\n    if (colliding) {\n      return {\n        ...state,\n        colliding: getColliding(direction, leftStates, index),\n      }\n    }\n    else {\n      return state;\n    }\n  });\n\n  // Right\n  // The right state is any changes to the left state. And includes the creation\n  // of completely new state.\n  let rightIndex = 0;\n  for (const words of rightWordArrays) {\n    const matchingLeft = leftWordArrays[rightIndex];\n    let state;\n    if (matchingLeft) {\n      // If there's a matching left state, then this state is a mutation of that\n      // state. It may be a small change like adding DEAD to a Player.\n      // Eg: [ Mario | Goomba ] -> [ DEAD Mario | Goomba ]\n      state = wordsToState(words, names);\n    }\n    else {\n      // If there is no matching let state, then this is a completely new state.\n      // Eg: the fireball in this rule: [ <ACTION> Mario ] -> [ Mario | Fireball ]\n      const newSprite = createNewSprite('TEMP_NAME', 0, 0);\n      state = {\n        ...newSprite,\n        createNew: {direction}, // indicates to applyStateMutations not to merge this but create new state\n        ...wordsToState(words, names)\n        // I don't think the right side needs the colliding state calculated\n      }\n\n      // Duplicate the leftmost match state as the match for this new state\n      leftStatesWithColliding.push({...leftStates[0]});\n    }\n\n    rightStates.push(state);\n    rightIndex += 1;\n  }\n\n  // State pairs to state mutations\n  return leftStatesWithColliding.map((leftState, index)=> [leftState, rightStates[index]]);\n\n  // const leftStateA = wordsToState(leftWordsA, names);\n  // const leftStateB = leftWordsB\n  //   ? wordsToState(leftWordsB, names)\n  //   : newSprite()\n    \n  // const rightStateA = wordsToState(rightWordsA, names);\n\n  // // User may omit rightWordsB. In which case populate it with leftWordsB\n  // // Eg: [ <ACTION> Player | Ground ] -> [ JUMP Player ]\n  // // Becomes: [ <ACTION> Player | Ground ] -> [ JUMP Player ]\n  // const rightStateB = wordsToState(rightWordsB ? rightWordsB : leftWordsB, names);\n\n  // // Pay close attention to the flipping of A and B for certain variables.\n  // // collidingA is used as the colliding state for spriteB and vice-a-versa\n  // let collidingA = {};\n  // collidingA[getOpposite(directionToSide(direction))] = [{...leftStateA}]\n\n  // let collidingB = {};\n  // collidingB[directionToSide(direction)] = [{...leftStateB}]\n\n  // const pairA = [\n  //   {...leftStateA, colliding: collidingB},\n  //   rightStateA\n  // ];\n  // const pairB = [\n  //   {...leftStateB, colliding: {...collidingA}},\n  //   rightStateB\n  // ];\n\n  // return [pairA, pairB];\n}\n\nconst wordsToState = (words, names)=> {\n  /* Turn those words into arrays of key value objects\n    [\n      [{name: \"Goomba\"}],\n      [{name: \"Goomba\"}, {acceleration: {x: 1}}]},\n      [{name: \"Goomba\"}, {acceleration: {y: 1}}]}\n    ]\n  */\n  const statesArr = words.map((word)=> {\n    if (names[word]) {\n      return ({\n        name: word\n      });\n    }\n    if (inputs[word]) {\n      return ({\n        inputs: {[inputs[word]]: true}\n      });\n    }\n    if (states[word]) {\n      return ({\n        ...states[word]\n      })\n    }\n\n    return {};\n  });\n\n  /* Flatten and merge all the states together into a single state object:\n    {name: \"Goomba\", acceleration: {x: 1, y: 1}}\n  */\n  let resultState = {};\n  for (const stateObj of statesArr) {\n    merge(resultState, stateObj);\n  }\n\n  return resultState;\n};\n\nexport const ruleToStateMutation = (ruleString, names)=> {\n  // First, turn the rule string into an array of words\n  // eg: the ruleString \"[ Goomba ] -> [ RIGHT Goomba ]\"\n  // becomes: [[\"Goomba\"], [\"RIGHT\", \"Goomba\"]]\n  const [leftWords, rightWords] = ruleString.split('->')\n    |> separateWords;\n    \n  const leftState = wordsToState(leftWords, names);\n  const rightState = wordsToState(rightWords, names);\n\n  return [leftState, rightState];\n}\n\nconst addVectors = (vectorA, vectorB)=> ({\n  x: vectorA.x + vectorB.x,\n  y: vectorA.y + vectorB.y\n});\n\nconst getDirectionOffset = (direction)=> {\n  const directionOffsetsMap = {\n    up: {x: 0, y: -TILE_SIZE},\n    down: {x: 0, y: TILE_SIZE},\n    left: {x: -TILE_SIZE, y: 0},\n    right: {x: TILE_SIZE, y: 0}\n  }\n\n  return directionOffsetsMap[direction];\n}\n\nexport const getNewStateToAdd = (sprites, mutations)=> {\n  const newState = [];\n\n  for (const sprite of sprites) {\n    for (const mutation of mutations) {\n      const [left, right] = mutation;\n\n      if (matches(left)(sprite)) {\n        // Add new sprite + give it a unique ID\n        newState.push({\n          ...right,\n          id: uniqid(),\n          position: addVectors(sprite.position, getDirectionOffset(right.createNew.direction)),\n          createNew: undefined\n        });\n      }\n    }\n  }\n\n  return newState;\n}\n\nexport const addNewState = (sprites, newState)=> {\n  return [\n    ...sprites,\n    ...newState\n  ]\n}\n\n// custom merge rules\nconst mergeCustomizer = (objValue, srcValue)=> {\n  if (isNumber(objValue)) {\n    return objValue + srcValue;\n  }\n}\n\nexport const applyStateMutations = (sprite, mutations)=> {\n  if (mutations.length === 0) {\n    return sprite;\n  }\n  \n  let resultState = {...sprite};\n\n  for (const mutation of mutations) {\n    const [left, right] = mutation;\n\n    if (matches(left)(sprite)) {\n      resultState = mergeWith(resultState, right, mergeCustomizer)\n    }\n  }\n\n  return resultState;\n};\n\nexport const isAlive = (sprite)=> !sprite.dead;\nexport const isCreateNewState = (stateMutation)=> {\n  const [, right] = stateMutation;\n  return right.createNew !== undefined;\n};","import {createNewSprite} from './state.js';\nimport {flatten} from 'lodash';\nimport {TILE_SIZE} from '../Game/constants.js';\nimport uniqid from 'uniqid';\n\nconst isCollisionRule = (line)=> line.includes('|');\nconst isRule = (line)=> line.includes('->') && !isCollisionRule(line);\nconst isLevel = (line)=> line.match(/#.+#/g)\nexport const isLegend = (line)=> line.includes('=');\n\nexport const parseLegend = (code)=> {\n  let legend = {};\n\n  code.split('\\n')\n    .filter(isLegend)\n    .forEach((line)=> {\n      const [symbol, right] = line.split('=').map((str)=> str.trim());\n      const names = right.split(' or ');\n      // this is a function to allow returning a random name in the case of:\n      // G = Goomba or Tree or Brick\n      legend[symbol] = ()=> {\n        const randIndex = Math.floor(Math.random() * names.length);\n        return names[randIndex];\n      }\n    });\n\n  return legend\n};\n\nconst removeEdges = (lines)=> (\n  lines.slice(1, -1).map((line)=> line.slice(1, -1))\n);\n\nexport const parseLevel = (code)=> (\n  code.split('\\n').filter(isLevel) |> removeEdges\n);\n\nexport const parseNames = (code)=> {\n  const lines = code.split('\\n').filter(isLegend);\n  const names = lines.map((line)=> {\n    const [, right] = line.split(' = ');\n    const words = right.split(' or ');\n    \n    return words;\n  });\n\n  return flatten(names);\n};\n\nexport const getLevelDimensions = (level)=> {\n  const width_in_tiles = level[0].length;\n  const height_in_tiles = level.length;\n  \n  return [width_in_tiles, height_in_tiles];\n}\n\nexport const parseSprites = (level, legend)=> {\n  const sprites = [];\n  level.map((line, row)=> line.split('').forEach((char, col)=> {\n    const getName = legend[char];\n    if (getName && getName() !== 'Empty') {\n      const x = col * TILE_SIZE;\n      const y = row * TILE_SIZE;\n      sprites.push(\n        {\n          id: uniqid(),\n          ...createNewSprite(getName(), x, y)\n        }\n      );\n    }\n  }));\n\n  return sprites;\n};\n\nconst expansionMappings = {\n  ALL: ['UP', 'DOWN', 'LEFT', 'RIGHT'],\n  HORIZONTAL: ['LEFT', 'RIGHT'],\n  VERTICAL: ['UP', 'DOWN']\n}\n\nconst isExpandable = (line)=> {\n  for (const key of Object.keys(expansionMappings)) {\n    if (line.includes(key)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n// replaces all occurrances of a word in a string with the given word\nconst replaceWord = (line, word, newWord)=> {\n  const newLine = line.replace(word, newWord)\n\n  // if more occurances of the word, then run replaceWord again\n  if (newLine.includes(word)) {\n    return replaceWord(newLine, word, newWord)\n  }\n\n  return newLine\n}\n\n/*\ntakes a single rule and expands it into several\nEg:\n  ALL [Player] -> [Player]\nBecomes:\n  UP [Player] -> [Player]\n  DOWN [Player] -> [Player]\n  LEFT [Player] -> [Player]\n  RIGHT [Player] -> [Player]\n */\nconst expandRule = (line)=> {\n  const lines = []\n  for (const [key, words] of Object.entries(expansionMappings)) {\n    if (line.includes(key)) {\n      for (const word of words) {\n        lines.push(\n          replaceWord(line, key, word)\n        );\n      }\n\n      // Return early once one keyword is dealt with\n      return lines;\n      /*\n      It's important to return early here once a keyword is found to prevent\n      this function from dealing with more than one keyword per execution\n      For example if a line contains both ALL and HORIZONTAL\n      Only one keyword can be dealt with per pass, else we end up with an output like:\n      UP [ _ ] -> [ HORIZONTAL ]\n      DOWN [ _ ] -> [ HORIZONTAL ]\n      LEFT [ _ ] -> [ HORIZONTAL ]\n      RIGHT [ _ ] -> [ HORIZONTAL ]\n      ALL [ _ ] -> [ LEFT ]\n      ALL [ _ ] -> [ RIGHT ]\n      Once the above expanded again, we would end up with a bunch of duplicate rules\n      */\n    }\n  }\n\n  return lines;\n}\n\nexport const expandRules = (lines)=> {\n  const alreadyExpanded = lines.filter((line)=> !isExpandable(line))\n  const freshlyExpanded = flatten(\n    lines.filter(isExpandable).map(expandRule)\n  )\n\n  if (freshlyExpanded.length === 0) {\n    // fully expanded, stop recursing\n    return lines\n  }\n  \n  return [\n    ...alreadyExpanded,\n    ...expandRules(freshlyExpanded)\n  ]\n}\n\n// If no direction given, then append 'ALL'. Otherwise use the given direction ('UP', 'DOWN', etc)\nconst addImplicitKeywords = (line) => {\n  const [firstWord] = line.split('[');\n  \n  let appendedLine = line;\n  if (firstWord === '') {\n    appendedLine = line.replace('[', 'ALL [');\n  }\n\n  return appendedLine;\n}\n\nexport const parseRules = (code)=> {\n  const regularRules = code\n    .split('\\n')\n    .filter(isRule)\n  \n  const collisionRules = code\n    .split('\\n')\n    .filter(isCollisionRule)\n    .map(addImplicitKeywords)\n\n  return [\n    expandRules(regularRules),\n    expandRules(collisionRules)\n  ]\n}","import {\n  TILE_SIZE, GROUND_FRICTION, AIR_FRICTION,\n  TOP, BOTTOM, LEFT, RIGHT\n} from './constants.js'\n\nexport const roundToPixels = (sprite)=> ({\n  ...sprite,\n  position: {\n    x: Math.round(sprite.position.x),\n    y: Math.round(sprite.position.y),\n  }\n});\n\nconst getEdges = (sprite)=> ({\n  top: sprite.position.y,\n  bottom: sprite.position.y + TILE_SIZE,\n  left: sprite.position.x,\n  right: sprite.position.x + TILE_SIZE\n});\n\nconst isOverlapping = (spriteA, spriteB)=> {\n  const a = getEdges(spriteA);\n  const b = getEdges(spriteB);\n  \n  return (\n    a.bottom > b.top &&\n    a.top < b.bottom &&\n    a.right > b.left &&\n    a.left < b.right\n  );\n};\n\nconst getPointsForSide = (side, sprite)=> {\n  // INSET is to prevent situations such as both TOP and LEFT/RIGHT colliding when 2 sprites are standing\n  // next to each other.\n  // It's not ideal because it means you do things like stand on a sprite just on the very outmost edge\n  // without triggering any UP DOWN collisions.\n  const INSET = 5;\n\n  if (side === LEFT) {\n    return [\n      {x: sprite.position.x, y: sprite.position.y + INSET},\n      {x: sprite.position.x, y: sprite.position.y + TILE_SIZE - INSET}\n    ]\n  }\n  if (side === RIGHT) {\n    return [\n      {x: sprite.position.x + TILE_SIZE, y: sprite.position.y + INSET},\n      {x: sprite.position.x + TILE_SIZE, y: sprite.position.y + TILE_SIZE - INSET}\n    ]\n  }\n  if (side === TOP) {\n    return [\n      {x: sprite.position.x + INSET, y: sprite.position.y},\n      {x: sprite.position.x + TILE_SIZE - INSET, y: sprite.position.y}\n    ]\n  }\n  if (side === BOTTOM) {\n    return [\n      {x: sprite.position.x + INSET, y: sprite.position.y + TILE_SIZE},\n      {x: sprite.position.x + TILE_SIZE - INSET, y: sprite.position.y + TILE_SIZE}\n    ]\n  }\n}\n\nconst overlapsPoint = (point, spriteB, padding = 0)=> {\n  const {x, y} = point;\n  const {top, bottom, left, right} = getEdges(spriteB);\n  return (\n    y > top - padding &&\n    y < bottom + padding &&\n    x > left - padding &&\n    x < right + padding\n  );\n}\n\nconst overlapsSide = (side, spriteA, spriteB)=> {\n  const points = getPointsForSide(side, spriteA);\n\n  for (const point of points) {\n    if (overlapsPoint(point, spriteB, 1)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst getCollidedEdges = (spriteA, spriteB)=> {\n  const prevEdgesA = getEdges({position: {...spriteA.prevPosition}});\n  const prevEdgesB = getEdges({position: {...spriteB.prevPosition}});\n  const collidedEdges = {top: false, bottom: false, left: false, right: false};\n\n  // by checking if an edge was not overlapping last frame but is this frame\n  // we can see which edge is colliding\n  if (prevEdgesA.top >= prevEdgesB.bottom) {\n    collidedEdges[TOP] = true;\n  }\n  else if (prevEdgesA.bottom <= prevEdgesB.top) {\n    collidedEdges[BOTTOM] = true;\n  }\n\n  if (prevEdgesA.left >= prevEdgesB.right) {\n    collidedEdges[LEFT] = true;\n  }\n  else if (prevEdgesA.right <= prevEdgesB.left) {\n    collidedEdges[RIGHT] = true;\n  }\n\n  return collidedEdges;\n}\n\nconst getAxisFromEdge = (edge)=> {\n  const edgeAxisMap = {\n    left: 'x',\n    right: 'x',\n    top: 'y',\n    bottom: 'y'\n  };\n\n  return edgeAxisMap[edge];\n}\n\nconst getSeparatedState = (edgeA, spriteA, spriteB)=> {\n  const edgesB = getEdges(spriteB);\n  const velocity = {...spriteA.velocity, [getAxisFromEdge(edgeA)]: 0};\n\n  let position = {...spriteA.position};\n  if (edgeA === TOP) {\n    position.y = edgesB[BOTTOM];\n  }\n  else if (edgeA === BOTTOM) {\n    position.y = edgesB[TOP] - TILE_SIZE;\n  }\n  else if (edgeA === LEFT) {\n    position.x = edgesB[RIGHT];\n  }\n  else if (edgeA === RIGHT) {\n    position.x = edgesB[LEFT] - TILE_SIZE;\n  }\n\n  return {position, velocity};\n}\n\nexport const updateSpriteCollidingState = (spriteA, sprites, width, height)=> {\n  if (spriteA.static) {\n    return spriteA;\n  }\n\n  let colliding = {...spriteA.colliding};\n\n  // sprites\n  for (const spriteB of sprites) {\n    if (spriteA.id === spriteB.id) {\n      continue;\n    }\n\n    for (const edge of [TOP, BOTTOM, LEFT, RIGHT]) {\n      if (overlapsSide(edge, spriteA, spriteB)) {\n        \n        const collidingSprite = {...spriteB}\n        // prevent recursion of colliding state by removing the colliding state from spriteB\n        // otherwise it can recurse forever: state.colliding.bottom.colliding.top.colliding.bottom...\n        collidingSprite.colliding = undefined\n\n        colliding[edge].push(collidingSprite)\n      }\n    }\n  }\n\n  // walls\n  const padding = 1;\n  if (spriteA.position.x < 0 + padding) {\n    colliding[LEFT].push({name: 'Wall'});\n  }\n  if (spriteA.position.x > width - TILE_SIZE - padding) {\n    colliding[RIGHT].push({name: 'Wall'});\n  }\n  if (spriteA.position.y < 0 + padding) {\n    colliding[TOP].push({name: 'Wall'});\n  }\n  if (spriteA.position.y > height - TILE_SIZE - padding) {\n    colliding[BOTTOM].push({name: 'Wall'});\n  }\n\n  return {...spriteA, colliding};\n};\n\nexport const applySpriteCollisions = (spriteA, sprites)=> {\n  if (spriteA.static) {\n    return spriteA;\n  }\n\n  for (const spriteB of sprites) {\n    if (spriteA.id === spriteB.id) {\n      continue;\n    }\n\n    if (isOverlapping(spriteA, spriteB)) {    \n      const collidedEdges = getCollidedEdges(spriteA, spriteB);\n      let newSpriteA = {...spriteA};\n      \n      if (collidedEdges[TOP]) {\n        newSpriteA = {\n          ...newSpriteA,\n          ...getSeparatedState(TOP, spriteA, spriteB)\n        }\n      }\n      else if (collidedEdges[BOTTOM]) {\n        newSpriteA = {\n          ...newSpriteA,\n          ...getSeparatedState(BOTTOM, spriteA, spriteB)\n        }\n      }\n\n      // Check if overlap has been resolved before resolving horizontal collisions\n      // This is a cheap trick to prevent sprite from catching on the corners\n      // of adjacent tiles (vertical is resolved first & the horizontal is avoided)\n      if (isOverlapping(newSpriteA, spriteB)) {\n        if (collidedEdges[LEFT]) {\n          newSpriteA = {\n            ...newSpriteA,\n            ...getSeparatedState(LEFT, spriteA, spriteB)\n          }\n        }\n        else if (collidedEdges[RIGHT]) {\n          newSpriteA = {\n            ...newSpriteA,\n            ...getSeparatedState(RIGHT, spriteA, spriteB)\n          }\n        }\n      }\n      \n      return newSpriteA;\n    }\n  }\n\n  return spriteA;\n};\n\nexport const applyWallCollisions = (sprite, width, height)=> {\n  if (sprite.static) {\n    return sprite;\n  }\n\n  const newPosition = {...sprite.position};\n\n  if (sprite.position.y > height - TILE_SIZE) {\n    newPosition.y = height - TILE_SIZE;\n  }\n\n  if (sprite.position.y < 0) {\n    newPosition.y = 0;\n  }\n\n  if (sprite.position.x > width - TILE_SIZE) {\n    newPosition.x = width - TILE_SIZE;\n  }\n\n  if (sprite.position.x < 0) {\n    newPosition.x = 0;\n  }\n  \n  return {\n    ...sprite,\n    position: newPosition\n  }\n};\n\nexport const storePreviousPosition = (sprite)=> ({\n  ...sprite,\n  prevPosition: {...sprite.position}\n});\n\nexport const applyAcceleration = (sprite)=> {\n  const {velocity, maxVelocity, acceleration} = sprite;\n  return {\n    ...sprite,\n    velocity: {\n      x: Math.max(Math.min(velocity.x + acceleration.x, maxVelocity.x), -maxVelocity.x),\n      y: Math.max(Math.min(velocity.y + acceleration.y, maxVelocity.y), -maxVelocity.y)\n    },\n    acceleration: {x: 0, y: 0}\n  }\n};\n\nexport const applyVelocity = (sprite)=> ({\n  ...sprite,\n  position: {\n    x: sprite.position.x + sprite.velocity.x,\n    y: sprite.position.y + sprite.velocity.y\n  }\n});\n\nexport const resetColliding = (sprite)=> ({\n  ...sprite,\n  colliding: {top: [], bottom: [], left: [], right: []},\n\n});\n\nexport const applyFriction = (sprite)=> ({\n  ...sprite,\n  velocity: {\n    x: (sprite.colliding.top.length > 0 || sprite.colliding.bottom.length > 0)\n      ? sprite.velocity.x * GROUND_FRICTION\n      : sprite.velocity.x * AIR_FRICTION,\n    y: (sprite.colliding.left.length > 0 || sprite.colliding.right.length > 0)\n      ? sprite.velocity.y * GROUND_FRICTION\n      : sprite.velocity.y * AIR_FRICTION,\n  }\n});","import {flatten} from 'lodash';\nimport {parseRules, parseSprites, parseLegend, parseLevel, parseNames,\n  getLevelDimensions} from '../util/parse.js';\nimport {ruleToStateMutation, collisionRuleToStateMutations, applyStateMutations,\n  isAlive, isCreateNewState, getNewStateToAdd, addNewState} from '../util/state.js'\nimport {storePreviousPosition, applyAcceleration, applyVelocity, applyFriction,\n  updateSpriteCollidingState, applySpriteCollisions, roundToPixels,\n  applyWallCollisions, resetColliding\n} from './physics';\nimport {TILE_SIZE} from '../Game/constants.js'\n\nconst defaultState = {\n  sprites: [],\n  legend: {},\n  names: {},\n  rules: [],\n  stateMutations: [],\n  width_in_tiles: 0,\n  height_in_tiles: 0,\n  active: false,\n  theme: 'dark',\n  debug: false,\n  imageMap: {},\n  images: ['player', 'brick', 'questionbrick', 'spike', 'goomba', 'goombared']\n};\n\nconst arrayToObject = (array) =>\n   array.reduce((obj, item) => {\n     obj[item] = true\n     return obj\n   }, {})\n\nconst removeComments = (code)=>\n  code.split('\\n').filter(\n    (line)=> !line.includes('//')\n  ).join('\\n')\n\nconst gameReducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'SET_ACTIVE':\n      return {\n        ...state,\n        active: action.active\n      }\n\n    case 'TOGGLE_DEBUG':\n      return {\n        ...state,\n        debug: !state.debug\n      }\n    \n    case 'SELECT_IMAGE':\n      const imageMap = {...state.imageMap}\n      const {variableName, imageName} = action\n      imageMap[variableName] = imageName;\n      return {\n        ...state,\n        imageMap\n      }\n    \n    case 'COMPILE':\n      try {\n        const code = removeComments(action.code);\n        const level = parseLevel(code);\n        const legend = parseLegend(code);\n        const sprites = parseSprites(level, legend);\n    \n      // Names is the legend mapped to have the values as keys. Used for fast name lookup.\n      // this used to use the legend before the random features were added.\n      // For this to work though, names needs to include all possible names, including those that might not be rendered onto\n      // the map the first time it is loaded. I suppose later on this should also include things spawned within rules that may\n      // not also appear in the legend.\n      // Ideally, I could refactor out this names object entirely. It seems like that should be possible.\n      const namesArr = parseNames(code);\n      const names = arrayToObject(namesArr);\n      \n      const imageMap = {...state.imageMap};\n      for (const name of namesArr) {\n        if (!imageMap[name]) {\n          imageMap[name] = state.images[name] ? name.toLowerCase() : 'player';\n        }\n      }\n\n        // A rule consists of a before and an after state referred to as a state mutation\n        const [rules, collisionRules] = parseRules(code);\n        const stateMutations = rules.map((rule)=> ruleToStateMutation(rule, names)); // [leftState, rightState]\n\n        // collisionRules are a bit more complicated\n        const collisionStateMutationPairs = collisionRules.map(\n          (rule)=> collisionRuleToStateMutations(rule, names)\n        );\n        const collisionStateMutations = flatten(collisionStateMutationPairs);\n        \n        // separate the collisionStateMutations into 2 groups: \n          // those that will spawn new state\n          // and those that will modify existing state\n        const collisionStateMutationsCreate = collisionStateMutations.filter(isCreateNewState);\n        const collisionStateMutationsModify = collisionStateMutations.filter((e)=> !isCreateNewState(e));\n\n        const [width_in_tiles, height_in_tiles] = getLevelDimensions(level);\n\n        return {\n          ...defaultState,\n          sprites,\n          legend,\n          rules: [...rules, ...collisionRules],\n          stateMutations,\n          collisionStateMutationsCreate,\n          collisionStateMutationsModify,\n          width: width_in_tiles * TILE_SIZE,\n          height: height_in_tiles * TILE_SIZE,\n          names,\n          imageMap\n        }\n      }\n      catch(err) {\n        console.error(err);\n        return {\n          ...defaultState,\n          error: 'Compilation error '\n        }\n      }\n\n    case 'UPDATE':\n      const previousState = {...state};\n      const stateToAdd = getNewStateToAdd(state.sprites, state.collisionStateMutationsCreate);\n      return {\n          ...state,\n          sprites: state.sprites.filter(isAlive)\n              |> ((sprites)=> addNewState(sprites, stateToAdd))\n              |> ((sprites)=> sprites.map(resetColliding))\n              |> ((sprites)=> sprites.map((sprite)=> updateSpriteCollidingState(\n                sprite, state.sprites, state.width, state.height\n              )))\n              |> ((sprites)=> sprites.map(storePreviousPosition))\n              |> ((sprites)=> sprites.map((sprite)=> applyStateMutations(sprite, state.stateMutations)))\n              |> ((sprites)=> sprites.map((sprite)=> applyStateMutations(sprite, state.collisionStateMutationsModify)))\n              |> ((sprites)=> sprites.map(applyFriction))\n              |> ((sprites)=> sprites.map(applyAcceleration))\n              |> ((sprites)=> sprites.map(applyVelocity))\n              |> ((sprites)=> sprites.map((sprite)=> applySpriteCollisions(sprite, state.sprites, previousState)))\n              |> ((sprites)=> sprites.map((sprite)=> applySpriteCollisions(sprite, state.sprites, previousState)))\n              |> ((sprites)=> sprites.map((sprite)=> applySpriteCollisions(sprite, state.sprites, previousState)))\n              |> ((sprites)=> sprites.map((sprite)=> applyWallCollisions(sprite, state.width, state.height)))\n              |> ((sprites)=> sprites.map(roundToPixels))\n      }\n    case 'SET_INPUT':\n    return {\n      ...state,\n      sprites: state.sprites.map(\n        (sprite)=> ({...sprite, inputs: {...sprite.inputs, [action.input]: true}})\n      )\n    };\n\n    case 'TOGGLE_THEME':\n      return {\n        ...state,\n        theme: state.theme === 'light' ? 'dark' : 'light'\n      };\n\n    case 'CANCEL_INPUT':\n      return {\n        ...state,\n        sprites: state.sprites.map(\n          (sprite)=> {\n            const newInputs = {...sprite.inputs};\n            newInputs[action.input] = undefined;\n            return {...sprite, inputs: newInputs}\n          }\n        )\n      };\n\n    default:\n      return state\n  }\n}\n\nexport default gameReducer","\nconst initialTileSets = [\n  [\n    [0, 1, 1, 0,],\n    [1, 1, 1, 1,],\n    [1, 1, 1, 1,],\n    [0, 1, 1, 0,]\n  ],\n  [\n    [0, 1, 1, 0,],\n    [1, 0, 0, 1,],\n    [1, 0, 0, 1,],\n    [0, 1, 1, 0,]\n  ]\n]\n\nconst tileImages = ['tile0', 'tile1', 'tile2', 'tile3']\n\nconst rasterise = (tileSet)=> {\n  const width = 128\n  const height = 128\n\n  const canvas = document.createElement('canvas')\n  canvas.width = width\n  canvas.height = height\n  \n  let ctx = canvas.getContext('2d')\n  tileSet.map((row, rowIndex)=> (\n    tileSet[rowIndex].map((col, colIndex)=> {\n      const tileImage = tileImages[tileSet[rowIndex][colIndex]]\n      const image = new Image(32, 32);\n      image.onload = function() {\n          console.log('loaded')\n          ctx.drawImage(image, col * 32, row * 32);\n      };\n      image.src = `../Game/images/tiles/${tileImage}.png`\n      // the src needs to be set after the onload because apparently\n      // sometimes the src can be loaded instantly (eg: if the image is cached)\n    })\n  ))\n\n  // produce png from canvas\n  var dataUri = canvas.toDataURL()\n\n  return dataUri\n}\n\nconst defaultState = {\n  tileSets: initialTileSets,\n  open: false,\n  images: initialTileSets.map((tileSet)=> rasterise(tileSet)),\n  tileImages\n}\n\nconst spriteEditorReducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'spriteEditor/SET_OPEN':\n      return {\n        ...state,\n        open: action.open\n      }\n    case 'spriteEditor/UPDATE_TILESETS':\n      return {\n        ...state,\n        tileSets: action.tileSets,\n        images: action.tileSets.map((tileSet)=> rasterise(tileSet))\n      }\n    default:\n      return state\n  }\n}\n\nexport default spriteEditorReducer","import {combineReducers} from 'redux';\nimport codeReducer from './Code/reducer.js';\nimport gameReducer from './Game/reducer.js';\nimport spriteEditorReducer from './SpriteEditor/reducer.js';\n\nexport default combineReducers({\n  code: codeReducer,\n  game: gameReducer,\n  spriteEditor: spriteEditorReducer\n})\n","import React from 'react';\nimport './debug.scss';\n\nexport const DebugColliding = ({sprite})=> (\n  <div className='debug-colliding'>\n    {Object.entries(sprite.colliding).map(([key, value], index)=> \n      <p className={`number ${key} ${value.length > 0 && 'active'}`}>\n        {value.length}\n      </p>\n    )}\n  </div>\n)","import React from 'react';\nimport {DebugColliding} from '../debug/DebugColliding.js';\nimport './Sprite.css';\n\nconst getPositionStyle = (x, y)=> ({\n  position: 'relative', left: x, top: y\n});\n\nconst Sprite = ({x, y, img, sprite, debug})=> (\n  <div className=\"sprite\" style={getPositionStyle(x, y)}>\n    <img src={require(`./images/${img}.png`)} alt='' />\n    {debug && <DebugColliding sprite={sprite} />}\n  </div>\n);\n\nexport default Sprite;\n","import React from 'react';\nimport Sprite from './Sprite.js';\n\nconst Game = ({sprites, width, height, imageMap, error, debug})=> (\n  <div className='stage' style={{width, height}}>\n    {error && <p className='error' >{error}</p>}\n    {sprites.map((sprite)=>\n      <Sprite\n        key={sprite.id}\n        x={sprite.position.x}\n        y={sprite.position.y}\n        img={imageMap[sprite.name] || 'player'}\n        sprite={sprite} // used for debug visualisation\n        debug={debug}\n      />\n    )}\n  </div>\n);\n\nexport default Game","import React, {useEffect} from 'react';\nimport {update} from './actions.js';\nimport {connect} from 'react-redux'\n\nconst Loop = ({onTimeChange})=> {\n  // recursively calls itself once per frame\n  let request;\n  const advanceFrame = ()=> {\n    onTimeChange();\n    request = requestAnimationFrame(()=> advanceFrame());\n  }\n\n  useEffect(() => {\n    request = requestAnimationFrame(()=> advanceFrame());\n    return function cleanup() {\n      cancelAnimationFrame(request);\n    }\n  }, []);\n\n  return <p></p>;\n};\n\nconst mapDispatchToProps = (dispatch)=> ({\n  onTimeChange: ()=> {\n    dispatch(update());\n  }\n});\n\nexport default connect(\n  null,\n  mapDispatchToProps\n)(Loop);\n","\nexport const update = ()=> ({\n  type: 'UPDATE'\n})\n\nexport const updateSprite = (sprite)=> ({\n  type: 'UPDATE_SPRITE',\n  sprite\n})\n\nexport const toggleDebug = (active)=> ({\n  type: 'TOGGLE_DEBUG',\n  active\n})\n\n","\nexport const updateCode = (code)=> ({\n  type: 'UPDATE_CODE',\n  code\n})\n\nexport const compile = (code)=> ({\n  type: 'COMPILE',\n  code\n})\n\nexport const setActive = (active)=> ({\n  type: 'SET_ACTIVE', active\n})\n","import React from 'react';\nimport {connect} from 'react-redux';\nimport Tooltip from '@material-ui/core/Tooltip';\n\nconst ImagePicker = ({variableName, imageMap, images, onSelect})=> {  \n  // imageMap will be an empty object before <Code /> has been loaded\n  // this protects against that case\n  if (Object.keys(imageMap).length === 0) {\n    return null;\n  }\n\n  const image = imageMap[variableName] ? imageMap[variableName] : 'player';\n\n  return (\n    <Tooltip\n      interactive\n      title={\n        <div className='tooltip-content'>\n          {images.map((name)=> (\n            <img\n              key={name}\n              alt=''\n              src={require(`../Game/images/${name}.png`)}\n              onClick={()=> onSelect(variableName, name)}\n            />\n          ))}\n        </div>\n      }\n    >\n      <img className='code-sprite'\n        alt=''\n        src={require(`../Game/images/${image}.png`)}\n      />\n    </Tooltip>\n  )\n};\n\nconst mapStateToProps = ({game})=> ({\n  imageMap: game.imageMap,\n  images: game.images\n})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  onSelect: (variableName, imageName)=> {\n    dispatch({\n      type: 'SELECT_IMAGE',\n      variableName,\n      imageName\n    });\n  }\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ImagePicker);\n","import React, {useEffect} from 'react';\nimport {updateCode, compile} from './actions.js';\nimport {connect} from 'react-redux';\nimport Prism from 'prismjs';\nimport {Editor} from 'slate-react';\nimport Plain from 'slate-plain-serializer';\nimport ImagePicker from '../ImagePicker/ImagePicker.js';\n\nconst makeGrammar = ()=> {\n  return {\n    comment: /\\/\\/.*/,\n    variable: {\n      pattern: new RegExp(' = ([A-Z]+)', 'i'),\n    }\n  }\n}\n\nconst grammar = makeGrammar();\n\nconst onKeyDown = (event, editor, next)=> {\n  if (event.ctrlKey && event.key === 'b') {\n    event.preventDefault()\n    console.log('add bold')\n    editor.addMark('bold')\n  } else {\n    return next()\n  }\n}\n\nconst getContent = (token)=> {\n  if (typeof token == 'string') {\n    return token\n  } else if (typeof token.content == 'string') {\n    return token.content\n  } else {\n    return token.content.map(getContent).join('')\n  }\n}\n\nconst decorateNode = (node, editor, next)=> {\n  const others = next() || []\n  const texts = node.getTexts().toArray()\n  const string = texts.map(t => t.text).join('\\n')\n\n  if (texts.length !== 1) {\n    return others;\n  }\n\n  const tokens = Prism.tokenize(string, grammar)\n  const decorations = []\n  let startText = texts.shift()\n  let endText = startText\n  let startOffset = 0\n  let endOffset = 0\n  let start = 0\n\n  for (const token of tokens) {\n    startText = endText\n    startOffset = endOffset\n\n    const content = getContent(token)\n    const newlines = content.split('\\n').length - 1\n    const length = content.length - newlines\n    const end = start + length\n\n    let available = startText.text.length - startOffset\n    let remaining = length\n\n    endOffset = startOffset + remaining\n\n    while (available < remaining && texts.length > 0) {\n      endText = texts.shift()\n      remaining = length - available\n      available = endText.text.length\n      endOffset = remaining\n    }\n\n    if (typeof token != 'string') {\n      const dec = {\n        anchor: {\n          key: startText.key,\n          offset: startOffset,\n        },\n        focus: {\n          key: endText.key,\n          offset: endOffset,\n        },\n        mark: {\n          type: token.type,\n        },\n      }\n\n      decorations.push(dec)\n    }\n\n    start = end\n  }\n\n  return [...others, ...decorations]\n}\n\nconst renderMark = (props, editor, next, imageMap) => {\n  const { children, attributes, node } = props\n\n  switch (props.mark.type) {\n    case 'variable':\n      const [, right] = node.text.split('=').map((str)=> str.trim())\n      const [firstName,] = right.split(' or ')\n\n      return <span {...attributes}>\n        {children}\n        <ImagePicker variableName={firstName} />\n      </span>\n    case 'comment':\n      return (\n        <span {...attributes} style={{ opacity: '0.33' }}>\n          {children}\n        </span>\n      )\n    case 'keyword':\n      return (\n        <span {...attributes} style={{ fontWeight: 'bold' }}>\n          {children}\n        </span>\n      )\n    default:\n      return next()\n  }\n}\n\nconst Code = ({code, imageMap, onUpdateCode, onCompile})=> {\n  // manually trigger code change on first load\n  useEffect(() => {\n    onCompile(code);\n  }, []);\n\n  return <Editor\n    className={'code'}\n    defaultValue={Plain.deserialize(code)}\n    onChange={onUpdateCode}\n    onKeyDown={onKeyDown}\n    decorateNode={decorateNode}\n    renderMark={(props, editor, next)=> renderMark(props, editor, next, imageMap)}\n  />\n};\n\nconst mapStateToProps = ({code, game})=> ({\n  code: code.code,\n  width: game.width, \n  height: game.height,\n  imageMap: game.imageMap\n})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  onUpdateCode: ({value})=> {\n    dispatch(updateCode(Plain.serialize(value)));\n  },\n  onCompile: (code)=> {\n    dispatch(compile(code));\n  }\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Code);\n","import React from 'react';\nimport './Tile.scss';\n\nconst getPositionStyle = (x, y)=> ({\n  position: 'relative', left: x, top: y\n});\n\nconst Tile = ({x, y, img, onClick})=> (\n  <div className='tile' style={getPositionStyle(x, y)}>\n    <img\n      src={require(`../Game/images/tiles/${img}.png`)}\n      alt=''\n      onClick={()=> onClick()}\n    />\n  </div>\n);\n\nexport default Tile;\n","import React, {useState} from 'react'\nimport {connect} from 'react-redux'\nimport Dialog from '@material-ui/core/Dialog';\nimport Tile from './Tile.js'\nimport {TILE_SIZE} from '../Game/constants.js';\nimport './SpriteEditor.scss';\n\nconst SpritePicker = ({images, tileSets, selectedTileSet, onSelect})=> (\n  <div className='image-list'>\n    {images.map((src, index)=>{\n      return (\n        <img\n          src={src}\n          alt=''\n          className={`image ${index === selectedTileSet && 'selected'}`}\n          onClick={()=> onSelect(index)}\n        />\n      )\n    })}\n  </div>\n)\n\nconst Preview = ({tiles, selectedTile, tileImages, onSelect})=> (\n  <div className='preview'>\n    {tiles.map((rowArr, row)=> (\n      rowArr.map((tileIndex, col)=> (\n        <Tile\n          img={tileImages[tileIndex]}\n          x={col * TILE_SIZE}\n          y={row * TILE_SIZE}\n          onClick={()=> onSelect(row, col, selectedTile)}\n        />\n      ))\n    ))}\n  </div>\n)\n\nconst TilePicker = ({selectedTile, tileImages, onSelect})=> (\n  <div className='picker'>\n    {tileImages.map((name, index)=> (\n      <img\n        key={name}\n        alt=''\n        className={index === selectedTile ? 'selected' : ''}\n        src={require(`../Game/images/tiles/${name}.png`)}\n        onClick={()=> onSelect(index)}\n      />\n    ))}\n  </div>\n)\n\nconst SpriteEditor = ({tileSets, tileImages, images, open, updateTileSets, onClose})=> {  \n  const [selectedTileSet, setSelectedTileSet] = useState(0);\n  const [selectedTile, setSelectedTile] = useState(0);\n  const tiles = tileSets[selectedTileSet]\n\n  return (\n    <Dialog open={open} onClose={onClose}>\n      <div className='container'>\n        <div className='left'>\n          <SpritePicker\n            images={images}\n            tileSets={tileSets}\n            selectedTileSet={selectedTileSet}\n            onSelect={setSelectedTileSet}\n          />\n        </div>\n        <div className='right'>\n          <Preview\n            tiles={tiles}\n            tileImages={tileImages}\n            selectedTile={selectedTile}\n            onSelect={(row, col, newTileIndex)=> {\n              const newTileSets = [...tileSets]\n              newTileSets[selectedTileSet][row][col] = newTileIndex\n              updateTileSets(newTileSets)\n            }}\n          />\n          <TilePicker\n            tileImages={tileImages}\n            selectedTile={selectedTile}\n            onSelect={setSelectedTile}\n          />\n        </div>\n      </div>\n    </Dialog>\n  )\n}\n\nconst mapStateToProps = ({game, spriteEditor})=> ({\n  open: spriteEditor.open,\n  tileImages: spriteEditor.tileImages,\n  images: spriteEditor.images,\n  tileSets: spriteEditor.tileSets\n})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  updateTileSets: (tileSets)=> {\n    dispatch({\n      type: 'spriteEditor/UPDATE_TILESETS',\n      tileSets,\n    })\n  }\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(SpriteEditor)\n","export const examples = {\nsimple_movement: `\n##################\n#                #\n#                #\n#       P        #\n#       #        #\n#      ###       #\n#     #####      #\n#                #\n#                #\n##################\n\nP = Player\n# = Brick\n\n// Accelerate down, like gravity\n[ Player ] -> [ DOWN Player ]\n\n// Move sideways with <LEFT> and <RIGHT> arrow keys\n[ <HORIZONTAL> Player ] -> [ HORIZONTAL Player ]\n`,\nsimple_platformer: `\n##################\n#                #\n#                #\n#                #\n#                #\n#                #\n#     ###?#      #\n#                #\n#    P       G   #\n##################\n\nP = Player\n# = Brick\n? = QuestionBrick\nG = Goomba\n\n// Accelerate down, like gravity\n[ Player ] -> [ DOWN Player ]\n[ Goomba ] -> [ DOWN Goomba ]\n\n// Move sideways with <LEFT> and <RIGHT> arrow keys\n[ <HORIZONTAL> Player ] -> [ HORIZONTAL Player ]\n\n// Jump when <UP> is pressed and when the bottom of Player\n// is touching Wall (Wall = anything)\nDOWN [ <UP> Player | Wall ] -> [ JUMP Player | Wall ]\n\n// Player dies if touching Goomba on the side\nHORIZONTAL [ Player | Goomba ] -> [ DEAD Player | Goomba ]\n\n// Jumping on top of Goomba kills the Goomba\nDOWN [ Player | Goomba ] -> [ Player | DEAD Goomba ]\n\n// Break bricks by head-butting\nUP [ Player | Brick ] -> [ Player | DEAD Brick ]\n\n// Head-butting QuestionBrick turns it into another Player\nUP [ Player | QuestionBrick ] -> [ Player | JUMP Player ]\n`,\nfour_way_movement: `\n###############\n#             #\n#             #\n#             #\n#      P      #\n#             #\n#             #\n###############\n\nP = Player\n# = Brick\n\n[ <HORIZONTAL> Player ] -> [ HORIZONTAL Player ]\n[ <VERTICAL> Player ] -> [ VERTICAL Player ]\n\n`\n}","import React, {useState, Fragment} from 'react';\nimport {connect} from 'react-redux'\nimport Textarea from 'react-textarea-autosize';\nimport {examples} from './exampleCode';\n\nconst ExamplesModal = ()=> {\n  const [visible, setVisible] = useState(false)\n\n  return visible \n  ?\n    <div className='blanket' onClick={()=> setVisible(false)}>\n      <div className='modal' onClick={(e)=> e.stopPropagation()}>\n        <h1>Examples</h1>\n        {Object.entries(examples).map(([key, value])=> \n          <Fragment key={key}>\n            <h2>{key}</h2>\n            <div className='example'>\n              <Textarea value={value} />\n            </div>\n          </Fragment>\n        )}\n      </div>\n    </div>\n  :\n    <button className='primary' onClick={()=> setVisible(true)}>\n      Examples\n    </button>\n}\n\nconst mapStateToProps = ()=> ({})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  loadPreset: (value)=> {\n    dispatch({type: 'code/LOAD_PRESET', value})\n  }\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ExamplesModal);\n","import React from 'react';\nimport {connect} from 'react-redux'\nimport {HotKeys} from 'react-hotkeys';\n\nimport Game from '../Game/Game.js';\nimport Loop from '../Game/Loop.js';\nimport Code from '../Code/Code.js';\nimport SpriteEditor from '../SpriteEditor/SpriteEditor';\nimport ExamplesModal from '../Examples/ExamplesModal';\nimport {compile, setActive} from '../Code/actions';\nimport {toggleDebug} from '../Game/actions.js';\nimport {setInput, cancelInput, toggleTheme} from './actions.js';\nimport CustomProperties from 'react-custom-properties';\nimport './App.scss';\n\nconst darkColors = {\n  primary: '#F1A0A0',\n  secondary: '#87FFAE',\n  dark: '#000000',\n  light: '#FDF6E2'\n}\n\nconst lightColors = {\n  primary: '#43153F',\n  secondary: '#87FFAE',\n  dark: '#FDF6E2',\n  light: '#FFFFFF'\n}\n\nconst keyMap = {\n  'up': {sequence: 'up', action: 'keydown'},\n  'down': {sequence: 'down', action: 'keydown'},\n  'left': {sequence: 'left', action: 'keydown'},\n  'right': {sequence: 'right', action: 'keydown'},\n  'action1': {sequence: 'x', action: 'keydown'},\n  'action2': {sequence: 'z', action: 'keydown'},\n\n  'cancel_up': {sequence: 'up', action: 'keyup'},\n  'cancel_down': {sequence: 'down', action: 'keyup'},\n  'cancel_left': {sequence: 'left', action: 'keyup'},\n  'cancel_right': {sequence: 'right', action: 'keyup'},\n  'cancel_action1': {sequence: 'x', action: 'keyup'},\n  'cancel_action2': {sequence: 'z', action: 'keyup'},\n};\n\nconst handlers = (onSetInput, onCancelInput, onReset, onRun, onToggleDebug, isGameActive)=> ({\n  'up': ()=> onSetInput('up'),\n  'down': ()=> onSetInput('down'),\n  'left': ()=> onSetInput('left'),\n  'right': ()=> onSetInput('right'),\n  'action1': ()=> onSetInput('action1'),\n  'action2': ()=> onSetInput('action2'),\n  'r': ()=> onReset(),\n  'd': ()=> onToggleDebug(),\n  'space': ()=> onRun(!isGameActive),\n\n  'cancel_up': ()=> onCancelInput('up'),\n  'cancel_down': ()=> onCancelInput('down'),\n  'cancel_left': ()=> onCancelInput('left'),\n  'cancel_right': ()=> onCancelInput('right'),\n  'cancel_action1': ()=> onCancelInput('action1'),\n  'cancel_action2': ()=> onCancelInput('action2'),\n});\n\nconst App = ({\n    code, compile, theme, sprites, imageMap, width, height, debug, error,\n    isGameActive, setGameActive, onToggleDebug, onSetInput, onCancelInput, onToggleTheme,\n    onToggleExamples, onOpenCloseSpriteEditor\n})=> {\n  const colors = theme === 'light' ? lightColors : darkColors;\n  \n  return (\n    <CustomProperties className=\"custom-properties-container\" properties={{\n      '--primary-color': colors.primary,\n      '--secondary-color': colors.secondary,\n      '--dark-color': colors.dark,\n      '--light-color': colors.light,\n      '--hover-color': `${colors.primary}22`  // 22 is is the alpha in hex\n    }}>\n      <div className=\"main\">\n        <div className=\"left\">\n          <header>\n            <h1 className='logo'>micro gg</h1>\n            <ExamplesModal />\n            <button className='primary' onClick={()=> onToggleTheme()}>\n              {theme === 'dark' ? 'light' : 'dark'}\n            </button>\n          </header>\n          <Code imageMap={imageMap} />\n        </div>\n        <HotKeys\n          handlers={handlers(\n            onSetInput,\n            onCancelInput,\n            ()=> compile(code),\n            (active)=> setGameActive(active),\n            ()=> onToggleDebug(),\n            isGameActive\n          )}\n          keyMap={keyMap}\n        >\n          <div className=\"right\">\n            <header>\n              <button className='primary' onClick={()=> compile(code)}>compile</button>\n              <button className='secondary' onClick={()=> setGameActive(!isGameActive)}>\n                {isGameActive ? 'pause' : 'run'}\n              </button>\n              {isGameActive && <Loop />}\n            </header>\n            <div className=\"game-container\">\n              <SpriteEditor\n                onClose={()=> onOpenCloseSpriteEditor(false)}\n              />\n              <Game\n              sprites={sprites}\n              imageMap={imageMap}\n              width={width}\n              height={height}\n              debug={debug}\n              error={error}\n            />\n          </div>\n          </div>\n        </HotKeys>\n      </div>\n    </CustomProperties>\n  );\n};\n\nconst mapStateToProps = ({code, game})=> ({\n  code: code.code,\n  theme: game.theme,\n  isGameActive: game.active,\n  sprites: game.sprites,\n  imageMap: game.imageMap,\n  width: game.width,\n  height: game.height,\n  debug: game.debug,\n  error: game.error\n})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  compile: (code)=> {\n    dispatch(compile(code));\n  },\n  setGameActive: (active)=> {\n    dispatch(setActive(active));\n  },\n  onSetInput: (input)=> {\n    dispatch(setInput(input));\n  },\n  onCancelInput: (input)=> {\n    dispatch(cancelInput(input));\n  },\n  onToggleDebug: ()=> {\n    dispatch(toggleDebug());\n  },\n  onToggleTheme: ()=> {\n    dispatch(toggleTheme());\n  },\n  onToggleExamples: ()=> {\n    dispatch({type: 'app/OPEN_EXAMPLES'})\n  },\n  onOpenCloseSpriteEditor: (open)=> {\n    dispatch({type: 'spriteEditor/SET_OPEN', open: open})\n  }\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(App);\n","\nexport const setInput = (input)=> ({\n  type: 'SET_INPUT',\n  input\n})\n\nexport const cancelInput = (input)=> ({\n  type: 'CANCEL_INPUT',\n  input\n})\n\nexport const toggleTheme = ()=> ({\n  type: 'TOGGLE_THEME'\n})\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {Provider} from 'react-redux'\nimport {createStore} from 'redux'\nimport { persistStore, persistReducer } from 'redux-persist'\nimport { PersistGate } from 'redux-persist/integration/react'\nimport storage from 'redux-persist/lib/storage'\nimport rootReducers from './reducers'\nimport './index.css';\nimport './fonts/FiraCode/fira_code.css';\nimport App from './App/App.js';\n\nconst persistConfig = {\n  key: 'root',\n  storage,\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducers);\n\nconst store = createStore(\n  persistedReducer, /* preloadedState, */\n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n );\n\nconst persistor = persistStore(store);\npersistor.purge();\n\nReactDOM.render(\n  <Provider store={store}>\n    <PersistGate loading={null} persistor={persistor}>\n      <App />\n    </PersistGate>\n  </Provider>,\n  document.getElementById('root')\n);\n","var map = {\n\t\"./brick.png\": 179,\n\t\"./goomba.png\": 180,\n\t\"./goombared.png\": 181,\n\t\"./no-image.png\": 182,\n\t\"./player.png\": 183,\n\t\"./questionbrick.png\": 184,\n\t\"./spike.png\": 185,\n\t\"./tiles/tile0.png\": 94,\n\t\"./tiles/tile1.png\": 95,\n\t\"./tiles/tile2.png\": 96,\n\t\"./tiles/tile3.png\": 97\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 65;","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAChJREFUWAnt0IEAAAAAw6D5Ux/khVBhwIABAwYMGDBgwIABAwYMvA8MECAAAc4qtccAAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAADZJREFUWAnt0EENAEAIA8HjzOMGi5Bggs/UwDYT2dXvcP+wvWkHCBAgQIAAAQIECBAgQIAAgQGlEANzhaA9CAAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAN1JREFUWAnF0EsOwyAQg2HUi7VH867H6RFT/4tIUZQHkBmwxHb8mVIm5rv8Pq+J/VRrGoD1pSzvaQDW+5UpgHX9NICLRTkZ/gPb9VMALhXFa4b+wH49iKEA94nSbYYBjtYDGQZwlyjcZwjgbD2YIQD3iLKjpAOu1gNKB7hDFJ0lFXC3HlQqwPdFyVXSADXrgaUBfFsU3CUFULseXArAd8XxmoQDWtYDDAf4pjhcm1BA63qQoQDfE0dbEgboWQ80DOBb4mBrQgC968GGAHxHHOvJY8CT9YAfA3xDHOrNH5CJQjHdlUHlAAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAARJJREFUWAljZCASrPp/le0ew23H/wz//RgZGLT+MzBIMTD8B2IGHiKNwKoMaBZ+0PV/q8Q/hl91QAujgRby4VdNuixOB0z6v439K8PPaqCCIqCvuUk3mjgdWB0A8fXP9UBfWxBnDPmqMBzQ/X+j3l+Gv1uBlsuQbyzxOlEcAPX5aXpZDnImE8ytoDj/xwAOdrr4HGYvC4wBSnBANs3jHGYfjAZHATSr3aFlaodZiE6DowCSz2mX1dAtReYzgUo4SCGDLEw/NhOoeKVFCUesF5hAZTuximmhjgmYCrVoYTCxZgJDAFSrDRwA5gJwlTpgLgBlQ4rqc0pdDi+KKTWIXP2jDhgNgdEQGA2B0RAYDYHREAAA23dKamEoqhoAAAAASUVORK5CYII=\""],"sourceRoot":""}