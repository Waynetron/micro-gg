{"version":3,"sources":["Game/images/tiles sync /^/.//.*/.png$","Game/images/brick.png","Game/images/goomba.png","Game/images/goombared.png","Game/images/no-image.png","Game/images/player.png","Game/images/questionbrick.png","Game/images/spike.png","Code/reducer.js","Game/constants.js","util/state.js","util/parse.js","Game/physics.js","Game/reducer.js","SpriteEditor/reducer.js","reducers.js","debug/DebugColliding.js","Game/Sprite.js","Game/Game.js","Game/Loop.js","Game/actions.js","Code/actions.js","ImagePicker/ImagePicker.js","Code/Code.js","SpriteEditor/Tile.js","SpriteEditor/SpriteEditor.js","Examples/exampleCode.js","Examples/ExamplesModal.js","App/App.js","App/actions.js","index.js","Game/images sync /^/.//.*/.png$","Game/images/tiles/tile0.png","Game/images/tiles/tile1.png","Game/images/tiles/tile2.png","Game/images/tiles/tile3.png"],"names":["map","./tile0.png","./tile1.png","./tile2.png","./tile3.png","webpackContext","req","id","webpackContextResolve","__webpack_require__","e","Error","code","keys","Object","resolve","module","exports","defaultState","gameReducer","state","arguments","length","undefined","action","type","objectSpread","TOP","LEFT","RIGHT","createNewSprite","name","x","y","position","prevPosition","velocity","maxVelocity","acceleration","friction","colliding","top","bottom","left","right","static","inputs","trimBrackets","rawString","string","trim","isObject","openIndex","indexOf","closeIndex","lastIndexOf","substr","states","UP","DOWN","FAST_UP","FAST_DOWN","FAST_LEFT","FAST_RIGHT","SLOW_UP","SLOW_DOWN","SLOW_LEFT","SLOW_RIGHT","JUMP","DEAD","dead","STATIC","<UP>","<DOWN>","<LEFT>","<RIGHT>","<ACTION>","<ACTION1>","<ACTION2>","getCollidingForSide","side","traverseDirection","currentIndex","nextIndex","collidesWith","console","error","nextColliding","defineProperty","getColliding","direction","leftStates","leftIndex","frontSide","down","up","directionToSide","backSide","forward","getOpposite","frontColliding","backColliding","wordsToState","words","names","statesArr","word","includes","_word$split","split","_word$split2","slicedToArray","number","Number","isNaN","rightState","resultState","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","Symbol","iterator","next","done","stateObj","value","merge","err","return","propertyRegex","wordRegex","objectRegex","numberRegex","isWord","Boolean","match","isProperty","isNumberString","splitOnFirstWordGroup","numOpenBrackets","i","char","charAt","slice","splitOnObject","_string$match","property","replace","remainder","concat","splitOnProperty","_string$match3","_string$match5","numberString","stringToWordGroups","_splitOnFirstWordGrou","_splitOnFirstWordGrou2","rest","toConsumableArray","stringToState","wordGroups","group","_property$split","_property$split2","trimmed","innerState","valueState","propertyToState","parseFloat","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","push","_i","getStateTransitions","rules","sprites","transitions","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","sprite","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_step11","_iterator11","rule","_rule","matches","isAlive","isCreateNewState","createNew","isCollisionRule","line","isRule","isLevel","isLegend","expansionMappings","ALL","HORIZONTAL","VERTICAL","isExpandable","_arr","key","replaceWord","newWord","newLine","expandRule","lines","_arr2","entries","_i2","_ref3","_ref2","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","expandRules","alreadyExpanded","filter","freshlyExpanded","flatten","addImplicitKeywords","_line$split3","appendedLine","parseRules","_code$split$filter2","_ref4","_code$split$filter$ma","regularRules","ruleString","_ruleString$split","_ruleString$split2","ruleStringToState","collisionRules","_ruleString$match","firstWord","toLowerCase","_ruleString$replace$s","_ruleString$replace$s2","leftWordGroupArrays","rightWordGroupArrays","rightStates","leftStatesWithColliding","index","rightIndex","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","matchingLeft","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","subState","newSprite","leftState","collisionRuleStringToState","collisionCreate","collisionModify","modify","create","roundToPixels","Math","round","getEdges","isOverlapping","spriteA","spriteB","a","b","overlapsPoint","point","padding","_getEdges","overlapsSide","points","getPointsForSide","getCollidedEdges","prevEdgesA","prevEdgesB","collidedEdges","getSeparatedState","edgeA","edgesB","applySpriteCollisions","newSpriteA","storePreviousPosition","applyAcceleration","max","min","applyVelocity","resetColliding","snapNearZero","num","abs","applyFriction","legend","width_in_tiles","height_in_tiles","active","theme","debug","imageMap","regular","stateTransitions","images","_sprites9","variableName","imageName","join","removeComments","level","parseLevel","forEach","_line$split$map","str","_line$split$map2","symbol","randIndex","floor","random","parseLegend","row","col","getName","uniqid","parseSprites","namesArr","_line$split","parseNames","reduce","obj","item","imageAvailable","_getLevelDimensions","getLevelDimensions","_getLevelDimensions2","width","height","stateToAdd","vectorA","vectorB","newState","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","transition","_transition","getNewStateToAdd","newSprites","addNewState","edge","collidingSprite","updateSpriteCollidingState","newStates","result","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_step12","_iterator12","mergeWith","applyStateTransitions","newPosition","applyWallCollisions","input","newInputs","initialTileSets","tileImages","rasterise","tileSet","canvas","document","createElement","ctx","getContext","rowIndex","colIndex","tileImage","image","Image","onload","log","drawImage","src","toDataURL","tileSets","open","spriteEditorReducer","combineReducers","codeReducer","game","spriteEditor","DebugColliding","_ref","react_default","className","getPositionStyle","Sprite","img","style","require","alt","DebugColliding_DebugColliding","Game","src_Game_Sprite","connect","dispatch","onTimeChange","request","useEffect","requestAnimationFrame","advanceFrame","cancelAnimationFrame","compile","onSelect","Tooltip_default","interactive","title","onClick","grammar","comment","variable","pattern","RegExp","onKeyDown","event","editor","ctrlKey","preventDefault","addMark","getContent","token","content","decorateNode","node","others","texts","getTexts","toArray","t","text","tokens","Prism","tokenize","decorations","startText","shift","endText","startOffset","endOffset","start","newlines","end","available","remaining","dec","anchor","offset","focus","mark","onUpdateCode","Plain","serialize","onCompile","slate_react_es","defaultValue","deserialize","onChange","renderMark","props","children","attributes","_node$text$split$map","_right$split","firstName","src_ImagePicker_ImagePicker","assign","opacity","fontWeight","Tile","SpritePicker","selectedTileSet","Preview","tiles","selectedTile","rowArr","tileIndex","src_SpriteEditor_Tile","TilePicker","_ref5","updateTileSets","onClose","_useState","useState","_useState2","setSelectedTileSet","_useState3","_useState4","setSelectedTile","Dialog_default","SpriteEditor_SpritePicker","SpriteEditor_Preview","newTileIndex","newTileSets","SpriteEditor_TilePicker","examples","simple_movement","simple_platformer","four_way_movement","loadPreset","visible","setVisible","stopPropagation","react","react_textarea_autosize_esm_browser","darkColors","primary","secondary","dark","light","lightColors","keyMap","sequence","action1","action2","cancel_up","cancel_down","cancel_left","cancel_right","cancel_action1","cancel_action2","handlers","onSetInput","onCancelInput","onReset","onRun","onToggleDebug","isGameActive","r","d","space","setGameActive","setActive","setInput","cancelInput","onToggleTheme","onToggleExamples","onOpenCloseSpriteEditor","colors","react_custom_properties_default","properties","--primary-color","--secondary-color","--dark-color","--light-color","--hover-color","Examples_ExamplesModal","src_Code_Code","index_es","Game_Loop","src_SpriteEditor_SpriteEditor","src_Game_Game","persistConfig","storage","persistedReducer","persistReducer","rootReducers","store","createStore","window","__REDUX_DEVTOOLS_EXTENSION__","persistor","persistStore","ReactDOM","render","es","integration_react","loading","src_App_App","getElementById","./brick.png","./goomba.png","./goombared.png","./no-image.png","./player.png","./questionbrick.png","./spike.png","./tiles/tile0.png","./tiles/tile1.png","./tiles/tile2.png","./tiles/tile3.png"],"mappings":"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","file":"static/js/main.b3de5706.chunk.js","sourcesContent":["var map = {\n\t\"./tile0.png\": 94,\n\t\"./tile1.png\": 95,\n\t\"./tile2.png\": 96,\n\t\"./tile3.png\": 97\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 136;","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAD5JREFUWAnt10ERADAIA7Ax87iZRXao6CcYaMmv1fPmJC9ZYLNv8vnNVoAAAQIECBAgQIAAAQIECFRyHe84/XTlDQmQUCOUAAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAYdJREFUWAntVz1LA0EQfbuEeAgi2EWsBCsL/0JqKytLf4KV+IGQIiDxxMqfYBOwECvr/AULK8FKSCeIzWlx6zzjQdibDRdwL80NhNy8zMx7O3N3YQzEUve4kePrCnBdcTvEItoYMCOLpeMTs/tmSO6QPTlgLSJpqbQB3g2Sndbk5PWSUw0P7KTr9q/tJYX1AK4rAqLPfNZZOhSwUGsENB1oOhDqwDdgTxMsr/PDa3lWBatslfNbeknbOzN76dRv6cA9iJtfTmEzLqvnqx1IkNz61TXMjyl8LVbDGK8KKArV8a0KyJAd+OQa5scUvharYYw3A3cv/4wl403UK9o2Sc77EtUuRepA5fyQAL1sBFQdQQSeYMlGQOBFJHcn7Pkmtq73zfY8b0C11Xfuuf2KlyOH/MIPCI5gBas3/0FOQtZhPZ+cflDAJz4OqVxLmhdjHdbT8prHMDgCrV0xMAqQXW1hNhYBZrQwei6p3FK5KNYtgpzktr8rsmyp0omhiKhjHMJhhtyMyf0DfCpzwbzHSMoAAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAYxJREFUWAntV0FKw1AQnT82WRQqtDvFdbdewVN06RFciRUCLiwFI648QjdCT+EV3HYtuEvRgosEE+dFAk2Y3ybgTzcZKM1M3rw3mUk+/xsS+w7DsyRJHg3RRZZlJ4i5MmPMR0b06nneTX86fTe5eBy/ieDIlaiFN/J8/5zx5AcQR00jaDPaDu8QBm12PfNdDwZt3gVo415XQNeBrgNqB2SBiA3zbY/5FD9cI1b3s2yS31NJme+OgyDcuhd+zedEafqwFbNfNshXO3BEtKiya7EqpvA1rBYDXi2gIGrjXy3gh+iyKq7FqpjC17BaDHjzOZvJ/qBs+Qsncyzalien6b0A/TJS95rkqwXotG6i6gjcSOmsXQH6QiTdkt1rMBiPn8xkUnsF1JtMlC2X/ma1upYdkKxmZbOOYDAcPv+HOOTAA76y9J9nLWCzXl+hci2paSzvgPBped1naB2B1i4XMcZZzQVxHU5oMw6KdcAuMNBmnFKFPHIhsIczgjbjiIxTqqw8L22MI9cQLWhC+xfEpII8G45emQAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAW5JREFUWAntlsFOwzAMhu1qrwMSnOAtYOLCk3SDM6IVD8IFTeMp2AleqJqxS5JtrsucCSlCai6J7dj/lyxWh8+0Iig5SgKIdlXy8KI9AUw38P9uoKH12W+dcyyuc7NuoKX1HQF9cv82upDY4pe47LPils8NIEW3QK8ANONCtYYIdi1x2eeFcAEo8XiQBLETjyE/hAuAT3QZTh4V4iwQH2zwyfWgGcH2Qnu17QJY4u0DJ7Y6OdhXI/52gfPHkVhyuwBk9xLnC57GIFLBsGjDfu0f2G4AyXRCuMWlZhaAJPz1yAIYvnYTJ3WHGVVON4BTPJZ3Q7gAGlo9cWWj1Xq9TVRVcx3ylPvQdAEgVF8A2B2m9pY8uGteGd2B3U+ekbXncgHUePNWAd4riPTah92BneyXvD0tc+kCkEwFkcRj1R2EX7zP5ceV9bf8hd7Po6g153yOe+1cAEv0VJ9ou3+CU0WO5U0A0w0UvwEs2YbSId8ezJqOYuBQ4gAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAU5JREFUWAljZCAA2v+v+09ACU5pRgbG/xWMgUw4FQAl8Eri00gtuVEHjIbAaAgMeAgwUlLQUKMsGPAQGHXAaAjgDAFgVTodhClN6YTMwZkNKxmDGEGWU5JNkdsDuMzBGQKU+pxY/SyEFMJCgpA6cuUJhgAw6Cb+//8fHB2kWALS0/F/fSchPQQdADQgr5Nhw2yggcSoBdu3//9+FqCeeUBOKTUcwPCf4X9yJ8P6pSCDCRnY9/8Y50mGD8CW7P8EQmpB8gSDFi31buJm4AjLY/T6ic3w/v/rBX4wMGxiYPhvCzGc+q1iv68MP7fM/L+ZC90B/f93SP5g+H8QZjlIHhgKBD1IdLwiLPzv8p7hz87e/xtkYWLd/zfq/WT4fhTI14OJEUsTjFNsBgF9ZvOL4f8joBzYh38Y/l7Epo4YMTJCgBhjiVcz6oDREBjwEAAAwOJpSUqjPhYAAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAX5JREFUWAlj/Njc/J9hIMFAOgBkN9NAeh5k96gDRkNgNARYKMmGXzs7pf78/i3HxsDwnLOm5iE5ZpHlgM9tbaL//v1b9OfXLw+Qpb+A+FNLyz5eLq5QxqKid6Q4hKw0ALR8McP//2DLGRgZ7zEyMv79//+/0+evXyeSYjlILckO+N/fLwDUpwXEX4AWJ/DX1Cj/Z2QsBRkGpO1BNCmA5ChgLCz8ALRADmYJ0OeMn1ta7EA1GuP//49g4sTSJDsA2WCw5a2tM4CWB4CiAYhrkeWJYZMcBciGfm5tLQY6Ig1sOQNDOG919X5keWLYFDkA6HN3kCVAejZvTc1aYixEV0NRFDAyMTUBDZzKwMx8Hd1gYvmUhcD//4oMf/+mMv/7x0WshejqKAoBYFkwDRj83H///AGVRYHohhPDpygEGBkY9gATIDD7M+4lxjKsaihtE/6fOZPs4KdKm5AxPf0bVp8RKUhRFBBpB15low4YDYHREBjwEGCktCTEm8mJkAQABD53sd5+Ls8AAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAhVJREFUWAm9lulOwkAUhaf1WXCNStwIavzhGmOMxrihj+JSTFqsPgpv4Wv4Fmw/JHSuR5Lb2NJhpqWUhEw7c++Z75wuIMQEn9bnZ6nruo8TSAh7kmbr5+dVEjnUbM5k1ckM0G40ZoVl1UiIUvv7+6FwAAoCh4iGzi2iJxxnMpOpCe7nLSHu2TVSmOt5Xo3P04yZAIbuRfT+kUI8Z0khNUDn42MB7m/jLrH5PFK4i8/rzlMDyH6/jsgT+7KkkCikou74/hLcX6vWkcJi1/NuVOtJ86kAaDBwVO5ZHBAv+ILT7GMM0PX9ZUgq3fN2AFxCCto6rjcGkH/uDZ2lScEIAI5WQHzF1LoRKSyjx6jeCADv+7qpe4YzTUELACdliF6ysOmIFFY7nqft0wJkcc+QgHjlY9U4FgBvtjVEeaFq1s4TlduuO7Z/LECAa6/dRFOgS0EJ0Ht/X4f7c42+fploDSkodZQAQRC86dXNKsalkAgA95twf2Ymb1BFtNHyvES9RIA83Yd4RIlPxAhAq9GowP1p2JjXAdEWUhjRHQEQUuZ27ePslpROfC4CgP96VUF0Ei/K6xw3YwVv1oh+BICkrOe1mUpHxlIIAfCsbsP9saoxr3mkUEUKR6wXAmBhateeN+PxfwpDALjfhftDLpj2CLM7SOHgbx9OoDD3bI5TsDquu4ef3C9eKHK0bXvfLvLax83hqXN+AWhR9c/gEiSNAAAAAElFTkSuQmCC\"","\nconst initialCode = `\n##################\n#                #\n#                #\n#                #\n#                #\n#                #\n#     ###?#      #\n#                #\n#    P       G   #\n##################\n\nP = Player\n# = Brick\n? = QuestionBrick\nG = Goomba\n\n// Accelerate down, like gravity\n{ Player } -> { DOWN Player }\n{ Goomba } -> { DOWN Goomba }\n\n// Move sideways with <LEFT> and <RIGHT> arrow keys\n{ <HORIZONTAL> Player } -> { HORIZONTAL Player }\n\n// Jump when <UP> is pressed and when the bottom of Player\n// is touching Wall (Wall = anything)\nDOWN { <UP> Player | Wall } -> { JUMP Player | Wall }\n\n// Player dies if touching Goomba on the side\nHORIZONTAL { Player | Goomba } -> { DEAD Player | Goomba }\n\n// Jumping on top of Goomba kills the Goomba\nDOWN { Player | Goomba } -> { Player | DEAD Goomba }\n\n// Break bricks by head-butting\nUP { Player | Brick } -> { Player | DEAD Brick }\n\n// Head-butting QuestionBrick turns it into another Player\nUP { Player | QuestionBrick } -> { Player | JUMP Player }\n`;\n\nconst defaultState = {\n  code: initialCode\n}\n\nconst gameReducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'UPDATE_CODE':\n      return {...state, code: action.code}\n    default:\n      return state\n  }\n}\n\nexport default gameReducer","\nexport const TILE_SIZE = 32;\nexport const MAX_VELOCITY = 20;\nexport const TOP = 'top';\nexport const BOTTOM = 'bottom';\nexport const LEFT = 'left';\nexport const RIGHT = 'right';","import uniqid from 'uniqid';\nimport {matches, mergeWith, merge, isNumber} from 'lodash';\nimport {MAX_VELOCITY, TILE_SIZE} from '../Game/constants.js';\n\nexport const createNewSprite = (name, x, y)=> ({\n  name: name,\n  position: {x, y},\n  prevPosition: {x, y},\n  velocity: {x: 0, y: 0},\n  maxVelocity: {x: MAX_VELOCITY, y: MAX_VELOCITY},\n  acceleration: {x: 0, y: 0},\n  friction: 0.15,\n  colliding: {\n    top: [],\n    bottom: [],\n    left: [],\n    right: []\n  },\n  static: false,\n  inputs: {}\n});\n\n// also removes a single space on the outside of the bracket (if one exists)\n// otherwise it's possible to end up with multiple spaces where brackets stack\n// eg: '{ velocity: { y: -150 } }'   *could become*   ' velocity: { y: -150  }'\nexport const trimBrackets = (rawString)=> {\n  const string = rawString.trim()\n    if (!isObject(string)) {\n      return rawString\n    }\n    const openIndex = string.indexOf('{');\n    const closeIndex = string.lastIndexOf('}');\n    \n    return string.substr(openIndex + 1, closeIndex - 1).trim();\n}\n\nconst separateWords = (string)=> string.trim().split(' ')\n\nconst states = {\n  UP: {acceleration: {y: -1}},\n  DOWN: {acceleration: {y: 1}},\n  LEFT: {acceleration: {x: -1}},\n  RIGHT: {acceleration: {x: 1}},\n  FAST_UP: {acceleration: {y: -6}},\n  FAST_DOWN: {acceleration: {y: 6}},\n  FAST_LEFT: {acceleration: {x: -6}},\n  FAST_RIGHT: {acceleration: {x: 6}},\n  SLOW_UP: {acceleration: {y: -0.5}},\n  SLOW_DOWN: {acceleration: {y: 0.5}},\n  SLOW_LEFT: {acceleration: {x: -0.5}},\n  SLOW_RIGHT: {acceleration: {x: 0.5}},\n  JUMP: {velocity: {y: -150}},\n  DEAD: {dead: true},\n  STATIC: {static: true}\n};\n\nconst inputs = {\n  '<UP>': 'up',\n  '<DOWN>': 'down',\n  '<LEFT>': 'left',\n  '<RIGHT>': 'right',\n  '<ACTION>': 'action1',\n  '<ACTION1>': 'action1',\n  '<ACTION2>': 'action2'\n};\n\nconst getOpposite = (direction)=> {\n  const oppositeMappings = {\n    'left': 'right',\n    'right': 'left',\n    'top': 'bottom',\n    'bottom': 'top',\n    'up': 'down',\n    'down': 'up',\n    'forward': 'backward'\n  }\n\n  return oppositeMappings[direction];\n}\n\nconst directionToSide = (direction)=> {\n  const mappings = {\n    'left': 'left',\n    'right': 'right',\n    'down': 'bottom',\n    'up': 'top'\n  }\n\n  return mappings[direction];\n}\n\n// Recursively finds the colliding state\nconst getCollidingForSide = (side, traverseDirection, states, currentIndex)=> {\n  const nextIndex = traverseDirection === 'forward' ? currentIndex + 1 : currentIndex - 1;\n  // outside range\n  if (nextIndex < 0 || nextIndex === states.length) {\n    return;\n  }\n\n  const collidesWith = states[nextIndex];\n  if (!collidesWith) {\n    console.error('Expecting there to always be a state here');\n  }\n\n  let state = [{\n    ...collidesWith\n  }];\n\n  const nextColliding = getCollidingForSide(side, traverseDirection, states, nextIndex);\n  if (nextColliding) {\n    state.colliding = {\n      [side]: nextColliding\n    }  \n  }\n\n  return state;\n}\n\nconst getColliding = (direction, leftStates, leftIndex)=> {\n  // direction refers to the direction the collision rule is applied in.\n  // getCollidingForSide('bottom', 'forward' ... refers to searching for the\n  // colliding state for the bottom side by traversing the ruleString to the\n  // right (forward)\n  let colliding = {};\n  const frontSide = directionToSide(direction);\n  const backSide = getOpposite(frontSide);\n  const frontColliding = getCollidingForSide(frontSide, 'forward', leftStates, leftIndex);\n  const backColliding = getCollidingForSide(backSide, 'backward', leftStates, leftIndex);\n\n  if (backColliding) {\n    colliding[backSide] = backColliding;\n  }\n\n  if (frontColliding) {\n    colliding[frontSide] = frontColliding;\n  }\n\n  if (frontColliding || backColliding) {\n    return colliding; \n  }\n  else {\n    return;\n  }\n}\n\n/*\nStarts withObject.keys( ).length > 0 ? colliding : undefined;\n  [ UP Player | Spike ] -> [ DEAD Player | Spike ]\nBreaks up into 2 rules\n  [ UP Player] -> [ DEAD Player]\n  [ Spike ] -> [ Spike ]\nEvaluate both rules into a pair of state transitions\n[\n  {name: \"Player\", acceleration: {x: 1, y: 0}},\n  {name: \"Player\", dead: true}\n]\n[\n  {name: \"Spike\"},\n  {name: \"Spike\"}\n]\n// Finally adds a colliding property to the left side each state transition\n[\n  {\n    name: \"Player\", acceleration: {x: 1, y: 0},\n    colliding: {\n      top: {name:'Spike'}, bottom: {name:'Spike'},\n      left: {name:'Spike'}, right: {name:'Spike'}\n    }\n  },\n  {name: \"Player\", dead: true}\n]\n[\n  {\n    name: \"Spike\",\n    colliding: {\n      top: {name:'Player'}, bottom: {name:'Player'},\n      left: {name:'Player'}, right: {name:'Player'}\n    }\n  }\n  {name: \"Spike\"}\n]\n*/\nexport const collisionRuleStringToState = (ruleString, names)=> {\n  // Get collision direction (first word at the start of the line)\n  const [firstWord] = ruleString.match(/^([A-Z]+)\\b/);\n  const direction = firstWord.toLowerCase();\n\n  // Get the left and right matches\n  const [left, right] = ruleString.replace(firstWord, '').split('->');\n\n  // <------- leftWordArrays ----->    <--- rightWordArrays -->\n  // <---words--> < ----words----->    <-words-> <---words---->\n  // [ UP Player | Goomba | Brick ] -> [ Player | DEAD Goomba ]\n\n  const leftWordGroupArrays = trimBrackets(left).split('|')\n    .map((string)=> stringToWordGroups(string))\n\n  const rightWordGroupArrays = trimBrackets(right)\n    .split('|')\n    .map((string)=> stringToWordGroups(string))\n\n  let leftStates = [];\n  let rightStates = [];\n\n  // Left\n  // The left side is what the rule is looking to match.\n  // The colliding state should recursively nest colliding states if the rule\n  // has multiple collisions\n  for (const words of leftWordGroupArrays) {\n    const state = {\n      ...wordsToState(words, names)\n    }\n\n    leftStates.push(state);\n  }\n\n  const leftStatesWithColliding = leftStates.map((state, index)=> {\n    const colliding = getColliding(direction, leftStates, index);\n\n    if (colliding) {\n      return {\n        ...state,\n        colliding: getColliding(direction, leftStates, index),\n      }\n    }\n    else {\n      return state;\n    }\n  });\n\n  // Right\n  // The right state is any changes to the left state. And includes the creation\n  // of completely new state.\n  let rightIndex = 0;\n  for (const words of rightWordGroupArrays) {\n    const matchingLeft = leftWordGroupArrays[rightIndex]\n    let state = {};\n    if (matchingLeft) {\n      // If there's a matching left state, then this state is a transition of that\n      // state. It may be a small change like adding DEAD to a Player.\n      // Eg: [ Mario | Goomba ] -> [ DEAD Mario | Goomba ]\n      \n      // Flatten and merge all the states together into a single state object\n      const states = words.map((string)=> stringToState(string, names))\n      for (const subState of states) {\n        merge(state, subState);\n      }\n    }\n    else {\n      // If there is no matching let state, then this is a completely new state.\n      // Eg: the fireball in this rule: [ <ACTION> Mario ] -> [ Mario | Fireball ]\n      const newSprite = createNewSprite('TEMP_NAME', 0, 0);\n      state = {\n        ...newSprite,\n        // indicates to applyRules not to merge this but create new state\n        createNew: {direction},\n        ...wordsToState(words, names)\n        // I don't think the right side needs the colliding state calculated\n      }\n\n      // Duplicate the leftmost match state as the match for this new state\n      leftStatesWithColliding.push({...leftStates[0]});\n    }\n\n    rightStates.push(state);\n    rightIndex += 1;\n  }\n\n  // State pairs to state transitions\n  return leftStatesWithColliding.map((leftState, index)=> [leftState, rightStates[index]]);\n\n  // const leftStateA = wordsToState(leftWordsA, names);\n  // const leftStateB = leftWordsB\n  //   ? wordsToState(leftWordsB, names)\n  //   : newSprite()\n    \n  // const rightStateA = wordsToState(rightWordsA, names);\n\n  // // User may omit rightWordsB. In which case populate it with leftWordsB\n  // // Eg: [ <ACTION> Player | Ground ] -> [ JUMP Player ]\n  // // Becomes: [ <ACTION> Player | Ground ] -> [ JUMP Player ]\n  // const rightStateB = wordsToState(rightWordsB ? rightWordsB : leftWordsB, names);\n\n  // // Pay close attention to the flipping of A and B for certain variables.\n  // // collidingA is used as the colliding state for spriteB and vice-a-versa\n  // let collidingA = {};\n  // collidingA[getOpposite(directionToSide(direction))] = [{...leftStateA}]\n\n  // let collidingB = {};\n  // collidingB[directionToSide(direction)] = [{...leftStateB}]\n\n  // const pairA = [\n  //   {...leftStateA, colliding: collidingB},\n  //   rightStateA\n  // ];\n  // const pairB = [\n  //   {...leftStateB, colliding: {...collidingA}},\n  //   rightStateB\n  // ];\n\n  // return [pairA, pairB];\n}\n\nconst wordsToState = (words, names)=> {\n  /* Turn those words into arrays of key value objects\n    [\n      [{name: \"Goomba\"}],\n      [{name: \"Goomba\"}, {acceleration: {x: 1}}]},\n      [{name: \"Goomba\"}, {acceleration: {y: 1}}]}\n    ]\n  */\n  const statesArr = words.map((word)=> {\n    if (names[word]) {\n      return ({\n        name: word\n      });\n    }\n    if (inputs[word]) {\n      return ({\n        inputs: {[inputs[word]]: true}\n      });\n    }\n    if (states[word]) {\n      return ({\n        ...states[word]\n      })\n    }\n\n    if (word.includes(':')) {\n      const [left, right] = word.split(':')\n\n      // Number\n      const number = Number(right.trim())\n      if (typeof number === 'number' && !isNaN(number)) {\n        return {[left]: number}\n      }\n\n      // Object\n      const rightState = wordsToState([right.trim()], names)\n      return {[left]: {...rightState}}\n    }\n\n    return {};\n  });\n\n  /* Flatten and merge all the states together into a single state object:\n    {name: \"Goomba\", acceleration: {x: 1, y: 1}}\n  */\n  let resultState = {};\n  for (const stateObj of statesArr) {\n    merge(resultState, stateObj);\n  }\n\n  return resultState;\n};\n\n// export const trimPreceedingKeyword = (ruleString)=> {\n//   const directions = ['UP', 'DOWN', 'LEFT', 'RIGHT']\n//   const [left] = ruleString.split('[')\n//   const firstWord = left.trim()\n  \n//   if (directions.includes(firstWord)) {\n//     return ruleString.replace(firstWord, '').trim()\n//   }\n\n//   return ruleString;\n// }\n\n/* Splits string into word groupings eg: 'Player', 'friction: 0.1' */\nconst splitOnFirstWordGroupOldVersion = (string)=> {\n  const words = separateWords(string)\n\n  let i = 0\n  for (const word of words) {\n    if (!word.includes(':')) {\n      const split = [\n        words.slice(0, i + 1).join(\" \"),\n        words.slice(i + 1).join(\" \")\n      ]\n\n      return split\n    }\n\n    i++\n  }\n}\n\nconst propertyRegex = /^\\b[a-z_]+\\b\\s{0,1}[:]/i // property can't have space before colon\n// word can still match on ':', so must come after property\nconst wordRegex = /^[<]{0,1}[a-z_]+[0-9a-z_]*[>]{0,1}/i\nconst objectRegex = /^\\{/i // simply checks if string starts with '{'\nconst numberRegex = /^[-]{0,1}[0-9]*[.]{0,1}[0-9]+/\n\nconst isWord = (string)=> Boolean(string.match(wordRegex))\nconst isProperty = (string)=> Boolean(string.match(propertyRegex))\nconst isObject = (string)=> Boolean(string.match(objectRegex))\nconst isNumberString = (string)=> Boolean(string.match(numberRegex))\n\nconst splitOnProperty = (string)=> {\n  const [property] = string.match(propertyRegex)\n  const name = property.trim().replace(':', '')\n  const right = string.replace(property, '').trim()\n  \n  let numOpenBrackets = 0\n  for (var i = 0; i < right.length; i++) {\n    const char = right.charAt(i)\n\n    if (numOpenBrackets < 0) {\n      console.error('more closing brackets than opening brackets')\n    }\n\n    if (char === '{') {\n      numOpenBrackets++\n    }\n    else if (char === '}') {\n      numOpenBrackets--\n    }\n    else if (char === ' ' && numOpenBrackets === 0) {\n      const value = right.slice(0, i + 1).trim()\n      const remainder = right.slice(i + 1).trim()\n      \n      return [\n        `${name}: ${value}`,\n        remainder\n      ]\n    }\n  }\n\n  if (numOpenBrackets !== 0) {\n    console.error('unclosed brackets')\n  }\n  \n  // Made it to the end:\n  // value is entire string, no remainder\n  return  [`${name}: ${right}`, '']\n}\n\nconst splitOnObject = (string)=> {\n  let numOpenBrackets = 0\n  for (var i = 0; i < string.length; i++) {\n    const char = string.charAt(i)\n\n    if (numOpenBrackets < 0) {\n      console.error('more closing brackets than opening brackets')\n    }\n\n    if (char === '{') {\n      numOpenBrackets++\n    }\n    else if (char === '}') {\n      numOpenBrackets--\n    }\n    else if (char === ' ' && numOpenBrackets === 0) {\n      const objectString = string.slice(0, i + 1).trim()\n      const remainder = string.slice(i + 1).trim()\n\n      return [\n        objectString,\n        remainder\n      ]\n    }\n  }\n\n  if (numOpenBrackets !== 0) {\n    console.error('unclosed brackets')\n  }\n  \n  // Made it to the end:\n  // value is entire string, no remainder\n  return  [string, '']\n}\n\nconst splitOnFirstWordGroup = (rawString)=> {\n  const string = rawString.trim()\n\n  if (isObject(string)) {\n    return splitOnObject(string)\n  }\n\n  if (isProperty(string)) {\n    return splitOnProperty(string)\n  }\n\n  if (isWord(string)) {\n    const [word] = string.match(wordRegex)\n\n    return [word.trim(), string.replace(word, '')]\n  }\n\n  if (isNumberString(string)) {\n    const [numberString] = string.match(numberRegex)\n\n    return [numberString, string.replace(numberString, '')]\n  }\n\n  console.error('made it to the end without returning anything:', string)\n}\n\nconst stringToWordGroups = (string)=> {  \n  const [left, rest] = splitOnFirstWordGroup(string)\n\n  if (rest.length === 0) {\n    return [left]\n  }\n\n  return [left, ...stringToWordGroups(rest)]\n}\n\nconst propertyToState = (property, names)=> {\n  const firstColonRegex = /:(.+)/ \n  // the (.+) in the regex is to ensure the rest of the string is included in the 2nd arg\n  // without it, the string will split on every colon, not just the first\n  const [name, right] = property.split(firstColonRegex)\n  \n  if (isObject(right.trim())) {\n    const trimmed = trimBrackets(right.trim())\n    const innerState = stringToState(trimmed, names)\n    \n    return {\n      [name]: {...innerState},\n    }\n  }\n  else {\n    const valueState = stringToState(right.trim(), names)\n\n    return {\n      [name]: valueState,\n    }\n  }\n}\n\n// input: '{ Player carrying: Brick }'\n// output: { name: 'Player', carrying: {name: 'Brick'} }\nconst stringToState = (string, names)=> {\n  const wordGroups = stringToWordGroups(string)\n\n  if (wordGroups.length === 0) {\n    console.error('No word groups')\n  }\n  else if (wordGroups.length === 1) {\n    const [group] = wordGroups\n\n    // Property\n    if (isProperty(group)) {\n      return propertyToState(group, names)\n    }\n\n    // Expandable keyword\n    if (isWord(group)) {\n      return wordsToState([group], names)\n    }\n\n    if (isNumberString(group)) {\n      return parseFloat(group)\n    }\n\n    console.error('not dealing with:', wordGroups)\n    return {}\n  }\n\n  let states = []\n  for (const group of wordGroups) {\n    states.push(stringToState(group, names))\n  }\n\n  // Flatten and merge all the states together into a single state object\n  let resultState = {};\n  for (const state of states) {\n    merge(resultState, state);\n  }\n\n  return resultState\n}\n\n// { Player } -> { Player carrying: Brick }\nexport const ruleStringToState = (ruleString, names)=> {\n  const [left, right] = ruleString.split('->')\n\n  return [\n    stringToState(trimBrackets(left), names),\n    stringToState(trimBrackets(right), names)\n  ]\n}\n\nconst addVectors = (vectorA, vectorB)=> ({\n  x: vectorA.x + vectorB.x,\n  y: vectorA.y + vectorB.y\n});\n\nconst getDirectionOffset = (direction)=> {\n  const directionOffsetsMap = {\n    up: {x: 0, y: -TILE_SIZE},\n    down: {x: 0, y: TILE_SIZE},\n    left: {x: -TILE_SIZE, y: 0},\n    right: {x: TILE_SIZE, y: 0}\n  }\n\n  return directionOffsetsMap[direction];\n}\n\nexport const getNewStateToAdd = (sprites, transitions)=> {\n  const newState = [];\n\n  for (const sprite of sprites) {\n    for (const transition of transitions) {\n      const [left, right] = transition;\n\n      if (matches(left)(sprite)) {\n        // Add new sprite + give it a unique ID\n        newState.push({\n          ...right,\n          id: uniqid(),\n          position: addVectors(sprite.position, getDirectionOffset(right.createNew.direction)),\n          createNew: undefined\n        });\n      }\n    }\n  }\n\n  return newState;\n}\n\nexport const addNewState = (sprites, newState)=> {\n  return [\n    ...sprites,\n    ...newState\n  ]\n}\n\n// custom merge rules\n// const mergeCustomizer = (objValue, srcValue)=> {\n//   if (isNumber(objValue)) {\n//     return objValue + srcValue;\n//   }\n// }\n\nexport const getStateChanges = (sprites, transitions)=> {\n  if (transitions.length === 0) {\n    return {};\n  }\n\n  const stateChanges = sprites.map((sprite)=> {\n    let resultState = {...sprite};\n\n    for (const transition of transitions) {\n      const [left, right] = transition;\n\n      if (matches(left)(sprite)) {\n        resultState = mergeWith(resultState, right)\n      }\n    }\n\n    return resultState;\n  })\n\n  return stateChanges\n};\n\nexport const getStateTransitions = (rules, sprites)=> {\n  if (rules.length === 0) {\n    return []\n  }\n\n  const transitions = {}\n  for (const sprite of sprites) {\n    for (const rule of rules) {\n      const [left, right] = rule;\n      if (matches(left)(sprite)) {\n        if (!transitions[sprite.id]) {\n          transitions[sprite.id] = []\n        }\n        \n        transitions[sprite.id].push(right)\n      }\n    }\n  }\n\n  return transitions\n};\n\nexport const applyStateTransitions = (transitions, sprites)=> {\n  return sprites.map((sprite)=> {\n    const newStates = transitions[sprite.id]\n    if (newStates) {\n      let result = {...sprite}\n      for (const state of newStates) {\n        result = mergeWith(sprite, state)\n      }\n\n      return result\n    }\n\n    return sprite\n  })\n};\n\nexport const isAlive = (sprite)=> !sprite.dead;\nexport const isCreateNewState = (rule)=> {\n  const [, right] = rule;\n  return right.createNew !== undefined;\n};","import {createNewSprite} from './state.js';\nimport {flatten} from 'lodash';\nimport {TILE_SIZE} from '../Game/constants.js';\nimport uniqid from 'uniqid';\nimport {ruleStringToState, collisionRuleStringToState, isCreateNewState} from '../util/state.js'\n\nconst isCollisionRule = (line)=> line.includes('|');\nconst isRule = (line)=> line.includes('->') && !isCollisionRule(line);\nconst isLevel = (line)=> line.match(/#.+#/g)\nexport const isLegend = (line)=> line.includes('=');\n\nexport const parseLegend = (code)=> {\n  let legend = {};\n\n  code.split('\\n')\n    .filter(isLegend)\n    .forEach((line)=> {\n      const [symbol, right] = line.split('=').map((str)=> str.trim());\n      const names = right.split(' or ');\n      // this is a function to allow returning a random name in the case of:\n      // G = Goomba or Tree or Brick\n      legend[symbol] = ()=> {\n        const randIndex = Math.floor(Math.random() * names.length);\n        return names[randIndex];\n      }\n    });\n\n  return legend\n};\n\nconst removeEdges = (lines)=> (\n  lines.slice(1, -1).map((line)=> line.slice(1, -1))\n);\n\nexport const parseLevel = (code)=> (\n  code.split('\\n').filter(isLevel) |> removeEdges\n);\n\nexport const parseNames = (code)=> {\n  const lines = code.split('\\n').filter(isLegend);\n  const names = lines.map((line)=> {\n    const [, right] = line.split(' = ');\n    const words = right.split(' or ');\n    \n    return words;\n  });\n\n  return flatten(names);\n};\n\nexport const getLevelDimensions = (level)=> {\n  const width_in_tiles = level[0].length;\n  const height_in_tiles = level.length;\n  \n  return [width_in_tiles, height_in_tiles];\n}\n\nexport const parseSprites = (level, legend)=> {\n  const sprites = [];\n  level.map((line, row)=> line.split('').forEach((char, col)=> {\n    const getName = legend[char];\n    if (getName && getName() !== 'Empty') {\n      const x = col * TILE_SIZE;\n      const y = row * TILE_SIZE;\n      sprites.push(\n        {\n          id: uniqid(),\n          ...createNewSprite(getName(), x, y)\n        }\n      );\n    }\n  }));\n\n  return sprites;\n};\n\nconst expansionMappings = {\n  ALL: ['UP', 'DOWN', 'LEFT', 'RIGHT'],\n  HORIZONTAL: ['LEFT', 'RIGHT'],\n  VERTICAL: ['UP', 'DOWN']\n}\n\nconst isExpandable = (line)=> {\n  for (const key of Object.keys(expansionMappings)) {\n    if (line.includes(key)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n// replaces all occurrances of a word in a string with the given word\nconst replaceWord = (line, word, newWord)=> {\n  const newLine = line.replace(word, newWord)\n\n  // if more occurances of the word, then run replaceWord again\n  if (newLine.includes(word)) {\n    return replaceWord(newLine, word, newWord)\n  }\n\n  return newLine\n}\n\n/*\ntakes a single rule and expands it into several\nEg:\n  ALL [Player] -> [Player]\nBecomes:\n  UP [Player] -> [Player]\n  DOWN [Player] -> [Player]\n  LEFT [Player] -> [Player]\n  RIGHT [Player] -> [Player]\n */\nconst expandRule = (line)=> {\n  const lines = []\n  for (const [key, words] of Object.entries(expansionMappings)) {\n    if (line.includes(key)) {\n      for (const word of words) {\n        lines.push(\n          replaceWord(line, key, word)\n        );\n      }\n\n      // Return early once one keyword is dealt with\n      return lines;\n      /*\n      It's important to return early here once a keyword is found to prevent\n      this function from dealing with more than one keyword per execution\n      For example if a line contains both ALL and HORIZONTAL\n      Only one keyword can be dealt with per pass, else we end up with an output like:\n      UP [ _ ] -> [ HORIZONTAL ]\n      DOWN [ _ ] -> [ HORIZONTAL ]\n      LEFT [ _ ] -> [ HORIZONTAL ]\n      RIGHT [ _ ] -> [ HORIZONTAL ]\n      ALL [ _ ] -> [ LEFT ]\n      ALL [ _ ] -> [ RIGHT ]\n      Once the above expanded again, we would end up with a bunch of duplicate rules\n      */\n    }\n  }\n\n  return lines;\n}\n\nexport const expandRules = (lines)=> {\n  const alreadyExpanded = lines.filter((line)=> !isExpandable(line))\n  const freshlyExpanded = flatten(\n    lines.filter(isExpandable).map(expandRule)\n  )\n\n  if (freshlyExpanded.length === 0) {\n    // fully expanded, stop recursing\n    return lines\n  }\n  \n  return [\n    ...alreadyExpanded,\n    ...expandRules(freshlyExpanded)\n  ]\n}\n\n// If no direction given, then append 'ALL'. Otherwise use the given direction ('UP', 'DOWN', etc)\nexport const addImplicitKeywords = (line) => {\n  const [firstWord] = line.split('{');\n  \n  let appendedLine = line;\n  if (firstWord === '') {\n    appendedLine = line.replace('{', 'ALL {');\n  }\n\n  return appendedLine;\n}\n\nexport const parseRules = (code, names)=> {\n  const regularRules = code\n    .split('\\n')\n    .filter(isRule)\n    |> expandRules\n    |> ((ruleStrings)=> ruleStrings.map((string)=> ruleStringToState(string, names)))\n  \n  const collisionRules = code\n    .split('\\n')\n    .filter(isCollisionRule)\n    .map(addImplicitKeywords)\n    |> expandRules\n    |> ((ruleStrings)=> ruleStrings.map((string)=> collisionRuleStringToState(string, names)))\n    |> flatten\n  \n  // separate the collisionRules into 2 groups: \n  // those that will spawn new state\n  // and those that will modify existing state\n  const collisionCreate = collisionRules.filter(isCreateNewState);\n  const collisionModify = collisionRules.filter((rule)=> !isCreateNewState(rule));\n\n  return {\n    modify: [...regularRules, ...collisionModify],\n    create: collisionCreate\n  }\n}","import {\n  TILE_SIZE,\n  TOP, BOTTOM, LEFT, RIGHT\n} from './constants.js'\n\nexport const roundToPixels = (sprite)=> ({\n  ...sprite,\n  position: {\n    x: Math.round(sprite.position.x),\n    y: Math.round(sprite.position.y),\n  }\n});\n\nconst getEdges = (sprite)=> ({\n  top: sprite.position.y,\n  bottom: sprite.position.y + TILE_SIZE,\n  left: sprite.position.x,\n  right: sprite.position.x + TILE_SIZE\n});\n\nconst isOverlapping = (spriteA, spriteB)=> {\n  const a = getEdges(spriteA);\n  const b = getEdges(spriteB);\n  \n  return (\n    a.bottom > b.top &&\n    a.top < b.bottom &&\n    a.right > b.left &&\n    a.left < b.right\n  );\n};\n\nconst getPointsForSide = (side, sprite)=> {\n  // INSET is to prevent situations such as both TOP and LEFT/RIGHT colliding when 2 sprites are standing\n  // next to each other.\n  // It's not ideal because it means you do things like stand on a sprite just on the very outmost edge\n  // without triggering any UP DOWN collisions.\n  const INSET = 5;\n\n  if (side === LEFT) {\n    return [\n      {x: sprite.position.x, y: sprite.position.y + INSET},\n      {x: sprite.position.x, y: sprite.position.y + TILE_SIZE - INSET}\n    ]\n  }\n  if (side === RIGHT) {\n    return [\n      {x: sprite.position.x + TILE_SIZE, y: sprite.position.y + INSET},\n      {x: sprite.position.x + TILE_SIZE, y: sprite.position.y + TILE_SIZE - INSET}\n    ]\n  }\n  if (side === TOP) {\n    return [\n      {x: sprite.position.x + INSET, y: sprite.position.y},\n      {x: sprite.position.x + TILE_SIZE - INSET, y: sprite.position.y}\n    ]\n  }\n  if (side === BOTTOM) {\n    return [\n      {x: sprite.position.x + INSET, y: sprite.position.y + TILE_SIZE},\n      {x: sprite.position.x + TILE_SIZE - INSET, y: sprite.position.y + TILE_SIZE}\n    ]\n  }\n}\n\nconst overlapsPoint = (point, spriteB, padding = 0)=> {\n  const {x, y} = point;\n  const {top, bottom, left, right} = getEdges(spriteB);\n  return (\n    y > top - padding &&\n    y < bottom + padding &&\n    x > left - padding &&\n    x < right + padding\n  );\n}\n\nconst overlapsSide = (side, spriteA, spriteB)=> {\n  const points = getPointsForSide(side, spriteA);\n\n  for (const point of points) {\n    if (overlapsPoint(point, spriteB, 1)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst getCollidedEdges = (spriteA, spriteB)=> {\n  const prevEdgesA = getEdges({position: {...spriteA.prevPosition}});\n  const prevEdgesB = getEdges({position: {...spriteB.prevPosition}});\n  const collidedEdges = {top: false, bottom: false, left: false, right: false};\n\n  // by checking if an edge was not overlapping last frame but is this frame\n  // we can see which edge is colliding\n  if (prevEdgesA.top >= prevEdgesB.bottom) {\n    collidedEdges[TOP] = true;\n  }\n  else if (prevEdgesA.bottom <= prevEdgesB.top) {\n    collidedEdges[BOTTOM] = true;\n  }\n\n  if (prevEdgesA.left >= prevEdgesB.right) {\n    collidedEdges[LEFT] = true;\n  }\n  else if (prevEdgesA.right <= prevEdgesB.left) {\n    collidedEdges[RIGHT] = true;\n  }\n\n  return collidedEdges;\n}\n\nconst getAxisFromEdge = (edge)=> {\n  const edgeAxisMap = {\n    left: 'x',\n    right: 'x',\n    top: 'y',\n    bottom: 'y'\n  };\n\n  return edgeAxisMap[edge];\n}\n\nconst getSeparatedState = (edgeA, spriteA, spriteB)=> {\n  const edgesB = getEdges(spriteB);\n  const velocity = {...spriteA.velocity, [getAxisFromEdge(edgeA)]: 0};\n\n  let position = {...spriteA.position};\n  if (edgeA === TOP) {\n    position.y = edgesB[BOTTOM];\n  }\n  else if (edgeA === BOTTOM) {\n    position.y = edgesB[TOP] - TILE_SIZE;\n  }\n  else if (edgeA === LEFT) {\n    position.x = edgesB[RIGHT];\n  }\n  else if (edgeA === RIGHT) {\n    position.x = edgesB[LEFT] - TILE_SIZE;\n  }\n\n  return {position, velocity};\n}\n\nexport const updateSpriteCollidingState = (spriteA, sprites, width, height)=> {\n  if (spriteA.static) {\n    return spriteA;\n  }\n\n  let colliding = {...spriteA.colliding};\n\n  // sprites\n  for (const spriteB of sprites) {\n    if (spriteA.id === spriteB.id) {\n      continue;\n    }\n\n    for (const edge of [TOP, BOTTOM, LEFT, RIGHT]) {\n      if (overlapsSide(edge, spriteA, spriteB)) {\n        \n        const collidingSprite = {...spriteB}\n        // prevent recursion of colliding state by removing the colliding state from spriteB\n        // otherwise it can recurse forever: state.colliding.bottom.colliding.top.colliding.bottom...\n        collidingSprite.colliding = undefined\n\n        colliding[edge].push(collidingSprite)\n      }\n    }\n  }\n\n  // walls\n  const padding = 1;\n  if (spriteA.position.x < 0 + padding) {\n    colliding[LEFT].push({name: 'Wall'});\n  }\n  if (spriteA.position.x > width - TILE_SIZE - padding) {\n    colliding[RIGHT].push({name: 'Wall'});\n  }\n  if (spriteA.position.y < 0 + padding) {\n    colliding[TOP].push({name: 'Wall'});\n  }\n  if (spriteA.position.y > height - TILE_SIZE - padding) {\n    colliding[BOTTOM].push({name: 'Wall'});\n  }\n\n  return {...spriteA, colliding};\n};\n\nexport const applySpriteCollisions = (spriteA, sprites)=> {\n  if (spriteA.static) {\n    return spriteA;\n  }\n\n  for (const spriteB of sprites) {\n    if (spriteA.id === spriteB.id) {\n      continue;\n    }\n\n    if (isOverlapping(spriteA, spriteB)) {    \n      const collidedEdges = getCollidedEdges(spriteA, spriteB);\n      let newSpriteA = {...spriteA};\n      \n      if (collidedEdges[TOP]) {\n        newSpriteA = {\n          ...newSpriteA,\n          ...getSeparatedState(TOP, spriteA, spriteB)\n        }\n      }\n      else if (collidedEdges[BOTTOM]) {\n        newSpriteA = {\n          ...newSpriteA,\n          ...getSeparatedState(BOTTOM, spriteA, spriteB)\n        }\n      }\n\n      // Check if overlap has been resolved before resolving horizontal collisions\n      // This is a cheap trick to prevent sprite from catching on the corners\n      // of adjacent tiles (vertical is resolved first & the horizontal is avoided)\n      if (isOverlapping(newSpriteA, spriteB)) {\n        if (collidedEdges[LEFT]) {\n          newSpriteA = {\n            ...newSpriteA,\n            ...getSeparatedState(LEFT, spriteA, spriteB)\n          }\n        }\n        else if (collidedEdges[RIGHT]) {\n          newSpriteA = {\n            ...newSpriteA,\n            ...getSeparatedState(RIGHT, spriteA, spriteB)\n          }\n        }\n      }\n      \n      return newSpriteA;\n    }\n  }\n\n  return spriteA;\n};\n\nexport const applyWallCollisions = (sprite, width, height)=> {\n  if (sprite.static) {\n    return sprite;\n  }\n\n  const newPosition = {...sprite.position};\n\n  if (sprite.position.y > height - TILE_SIZE) {\n    newPosition.y = height - TILE_SIZE;\n  }\n\n  if (sprite.position.y < 0) {\n    newPosition.y = 0;\n  }\n\n  if (sprite.position.x > width - TILE_SIZE) {\n    newPosition.x = width - TILE_SIZE;\n  }\n\n  if (sprite.position.x < 0) {\n    newPosition.x = 0;\n  }\n  \n  return {\n    ...sprite,\n    position: newPosition\n  }\n};\n\nexport const storePreviousPosition = (sprite)=> ({\n  ...sprite,\n  prevPosition: {...sprite.position}\n});\n\nexport const applyAcceleration = (sprite)=> {\n  const {velocity, maxVelocity, acceleration} = sprite;\n  return {\n    ...sprite,\n    velocity: {\n      x: Math.max(Math.min(velocity.x + acceleration.x, maxVelocity.x), -maxVelocity.x),\n      y: Math.max(Math.min(velocity.y + acceleration.y, maxVelocity.y), -maxVelocity.y)\n    },\n    acceleration: {x: 0, y: 0}\n  }\n};\n\nexport const applyVelocity = (sprite)=> ({\n  ...sprite,\n  position: {\n    x: sprite.position.x + sprite.velocity.x,\n    y: sprite.position.y + sprite.velocity.y\n  }\n});\n\nexport const resetColliding = (sprite)=> ({\n  ...sprite,\n  colliding: {top: [], bottom: [], left: [], right: []},\n\n});\n\nconst snapNearZero = (num)=> Math.abs(num) > 0.0001 ? num : 0\n\nexport const applyFriction = (sprite)=> {\n  const x = sprite.velocity.x * (1 - sprite.friction)\n  const y = sprite.velocity.y * (1 - sprite.friction)\n  \n  return {\n    ...sprite,\n    velocity: {\n      x: snapNearZero(x),\n      y: snapNearZero(y),\n    }\n  }\n};","import {parseRules, parseSprites, parseLegend, parseLevel, parseNames,\n  getLevelDimensions} from '../util/parse.js';\nimport {getStateTransitions, isAlive, getNewStateToAdd, addNewState, applyStateTransitions} from '../util/state.js'\nimport {storePreviousPosition, applyAcceleration, applyVelocity, applyFriction,\n  updateSpriteCollidingState, applySpriteCollisions, roundToPixels,\n  applyWallCollisions, resetColliding\n} from './physics';\nimport {TILE_SIZE} from '../Game/constants.js'\n\nconst defaultState = {\n  sprites: [],\n  legend: {},\n  names: {},\n  width_in_tiles: 0,\n  height_in_tiles: 0,\n  active: false,\n  theme: 'dark',\n  debug: false,\n  imageMap: {},\n  rules: {\n    regular: [],\n    collisionCreate: [],\n    collisionModify: []\n  },\n  stateTransitions: {\n    regular: {}\n  },\n  images: ['player', 'brick', 'questionbrick', 'spike', 'goomba', 'goombared']\n};\n\nconst arrayToObject = (array) =>\n   array.reduce((obj, item) => {\n     obj[item] = true\n     return obj\n   }, {})\n\nconst removeComments = (code)=>\n  code.split('\\n').filter(\n    (line)=> !line.includes('//')\n  ).join('\\n')\n\nconst gameReducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'SET_ACTIVE':\n      return {\n        ...state,\n        active: action.active\n      }\n\n    case 'TOGGLE_DEBUG':\n      return {\n        ...state,\n        debug: !state.debug\n      }\n    \n    case 'SELECT_IMAGE':\n      const imageMap = {...state.imageMap}\n      const {variableName, imageName} = action\n      imageMap[variableName] = imageName;\n      return {\n        ...state,\n        imageMap\n      }\n    \n    case 'COMPILE':\n      try {\n        const code = removeComments(action.code);\n        const level = parseLevel(code);\n        const legend = parseLegend(code);\n        const sprites = parseSprites(level, legend);\n    \n      // Names is the legend mapped to have the values as keys. Used for fast name lookup.\n      // this used to use the legend before the random features were added.\n      // For this to work though, names needs to include all possible names, including those that might not be rendered onto\n      // the map the first time it is loaded. I suppose later on this should also include things spawned within rules that may\n      // not also appear in the legend.\n      // Ideally, I could refactor out this names object entirely. It seems like that should be possible.\n      const namesArr = parseNames(code);\n      const names = arrayToObject(namesArr);\n      \n      const imageMap = {...state.imageMap};\n      for (const name of namesArr) {\n        if (!imageMap[name]) {\n          const imageAvailable = state.images.includes(name.toLowerCase())\n          imageMap[name] = imageAvailable ? name.toLowerCase() : 'player';\n        }\n      }\n\n        // A rule consists of a before and an after state\n        const rules = parseRules(code, names);\n\n        const [width_in_tiles, height_in_tiles] = getLevelDimensions(level);\n\n        return {\n          ...defaultState,\n          sprites,\n          legend,\n          rules,\n          width: width_in_tiles * TILE_SIZE,\n          height: height_in_tiles * TILE_SIZE,\n          names,\n          imageMap\n        }\n      }\n      catch(err) {\n        console.error(err);\n        return {\n          ...defaultState,\n          error: 'Compilation error '\n        }\n      }\n\n    case 'UPDATE':\n      const previousState = {...state};\n      const stateToAdd = getNewStateToAdd(state.sprites, state.rules.create)\n      \n      const stateTransitions = {\n        modify: getStateTransitions(state.rules.modify, state.sprites),\n        create: getStateTransitions(state.rules.create, state.sprites),\n      }\n\n      const newSprites = state.sprites.filter(isAlive)\n        |> ((sprites)=> addNewState(sprites, stateToAdd))\n        |> ((sprites)=> sprites.map(resetColliding))\n        |> ((sprites)=> sprites.map((sprite)=> updateSpriteCollidingState(\n          sprite, state.sprites, state.width, state.height\n        )))\n        |> ((sprites)=> sprites.map(storePreviousPosition))\n        |> ((sprites)=> applyStateTransitions(stateTransitions.modify, sprites))\n        |> ((sprites)=> sprites.map(applyFriction))\n        |> ((sprites)=> sprites.map(applyAcceleration))\n        |> ((sprites)=> sprites.map(applyVelocity))\n        |> ((sprites)=> sprites.map((sprite)=> applySpriteCollisions(sprite, state.sprites, previousState)))\n        |> ((sprites)=> sprites.map((sprite)=> applySpriteCollisions(sprite, state.sprites, previousState)))\n        |> ((sprites)=> sprites.map((sprite)=> applySpriteCollisions(sprite, state.sprites, previousState)))\n        |> ((sprites)=> sprites.map((sprite)=> applyWallCollisions(sprite, state.width, state.height)))\n        |> ((sprites)=> sprites.map(roundToPixels))\n        \n      return {\n          ...state,\n          sprites: newSprites,\n          stateTransitions\n      }\n    case 'SET_INPUT':\n    return {\n      ...state,\n      sprites: state.sprites.map(\n        (sprite)=> ({...sprite, inputs: {...sprite.inputs, [action.input]: true}})\n      )\n    };\n\n    case 'TOGGLE_THEME':\n      return {\n        ...state,\n        theme: state.theme === 'light' ? 'dark' : 'light'\n      };\n\n    case 'CANCEL_INPUT':\n      return {\n        ...state,\n        sprites: state.sprites.map(\n          (sprite)=> {\n            const newInputs = {...sprite.inputs};\n            newInputs[action.input] = undefined;\n            return {...sprite, inputs: newInputs}\n          }\n        )\n      };\n\n    default:\n      return state\n  }\n}\n\nexport default gameReducer","\nconst initialTileSets = [\n  [\n    [0, 1, 1, 0,],\n    [1, 1, 1, 1,],\n    [1, 1, 1, 1,],\n    [0, 1, 1, 0,]\n  ],\n  [\n    [0, 1, 1, 0,],\n    [1, 0, 0, 1,],\n    [1, 0, 0, 1,],\n    [0, 1, 1, 0,]\n  ]\n]\n\nconst tileImages = ['tile0', 'tile1', 'tile2', 'tile3']\n\nconst rasterise = (tileSet)=> {\n  const width = 128\n  const height = 128\n\n  const canvas = document.createElement('canvas')\n  canvas.width = width\n  canvas.height = height\n  \n  let ctx = canvas.getContext('2d')\n  tileSet.forEach((row, rowIndex)=> (\n    tileSet[rowIndex].forEach((col, colIndex)=> {\n      const tileImage = tileImages[tileSet[rowIndex][colIndex]]\n      const image = new Image(32, 32);\n      image.onload = function() {\n          console.log('loaded')\n          ctx.drawImage(image, col * 32, row * 32);\n      };\n      image.src = `../Game/images/tiles/${tileImage}.png`\n      // the src needs to be set after the onload because apparently\n      // sometimes the src can be loaded instantly (eg: if the image is cached)\n    })\n  ))\n\n  // produce png from canvas\n  var dataUri = canvas.toDataURL()\n\n  return dataUri\n}\n\nconst defaultState = {\n  tileSets: initialTileSets,\n  open: false,\n  images: initialTileSets.map((tileSet)=> rasterise(tileSet)),\n  tileImages\n}\n\nconst spriteEditorReducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'spriteEditor/SET_OPEN':\n      return {\n        ...state,\n        open: action.open\n      }\n    case 'spriteEditor/UPDATE_TILESETS':\n      return {\n        ...state,\n        tileSets: action.tileSets,\n        images: action.tileSets.map((tileSet)=> rasterise(tileSet))\n      }\n    default:\n      return state\n  }\n}\n\nexport default spriteEditorReducer","import {combineReducers} from 'redux';\nimport codeReducer from './Code/reducer.js';\nimport gameReducer from './Game/reducer.js';\nimport spriteEditorReducer from './SpriteEditor/reducer.js';\n\nexport default combineReducers({\n  code: codeReducer,\n  game: gameReducer,\n  spriteEditor: spriteEditorReducer\n})\n","import React from 'react';\nimport './debug.scss';\n\nexport const DebugColliding = ({sprite})=> (\n  <div className='debug-colliding'>\n    {Object.entries(sprite.colliding).map(([key, value], index)=> \n      <p className={`number ${key} ${value.length > 0 && 'active'}`}>\n        {value.length}\n      </p>\n    )}\n  </div>\n)","import React from 'react';\nimport {DebugColliding} from '../debug/DebugColliding.js';\nimport './Sprite.css';\n\nconst getPositionStyle = (x, y)=> ({\n  position: 'relative', left: x, top: y\n});\n\nconst Sprite = ({x, y, img, sprite, debug})=> (\n  <div className=\"sprite\" style={getPositionStyle(x, y)}>\n    <img src={require(`./images/${img}.png`)} alt='' />\n    {debug && <DebugColliding sprite={sprite} />}\n  </div>\n);\n\nexport default Sprite;\n","import React from 'react';\nimport Sprite from './Sprite.js';\n\nconst Game = ({sprites, width, height, imageMap, error, debug})=> (\n  <div className='stage' style={{width, height}}>\n    {error && <p className='error' >{error}</p>}\n    {sprites.map((sprite)=>\n      <Sprite\n        key={sprite.id}\n        x={sprite.position.x}\n        y={sprite.position.y}\n        img={imageMap[sprite.name] || 'player'}\n        sprite={sprite} // used for debug visualisation\n        debug={debug}\n      />\n    )}\n  </div>\n);\n\nexport default Game","import React, {useEffect} from 'react';\nimport {update} from './actions.js';\nimport {connect} from 'react-redux'\n\nconst Loop = ({onTimeChange})=> {\n  // recursively calls itself once per frame\n  let request;\n  const advanceFrame = ()=> {\n    onTimeChange();\n    request = requestAnimationFrame(()=> advanceFrame());\n  }\n\n  useEffect(() => {\n    request = requestAnimationFrame(()=> advanceFrame());\n    return function cleanup() {\n      cancelAnimationFrame(request);\n    }\n  }, []);\n\n  return <p></p>;\n};\n\nconst mapDispatchToProps = (dispatch)=> ({\n  onTimeChange: ()=> {\n    dispatch(update());\n  }\n});\n\nexport default connect(\n  null,\n  mapDispatchToProps\n)(Loop);\n","\nexport const update = ()=> ({\n  type: 'UPDATE'\n})\n\nexport const updateSprite = (sprite)=> ({\n  type: 'UPDATE_SPRITE',\n  sprite\n})\n\nexport const toggleDebug = (active)=> ({\n  type: 'TOGGLE_DEBUG',\n  active\n})\n\n","\nexport const updateCode = (code)=> ({\n  type: 'UPDATE_CODE',\n  code\n})\n\nexport const compile = (code)=> ({\n  type: 'COMPILE',\n  code\n})\n\nexport const setActive = (active)=> ({\n  type: 'SET_ACTIVE', active\n})\n","import React from 'react';\nimport {connect} from 'react-redux';\nimport Tooltip from '@material-ui/core/Tooltip';\n\nconst ImagePicker = ({variableName, imageMap, images, onSelect})=> {  \n  // imageMap will be an empty object before <Code /> has been loaded\n  // this protects against that case\n  if (Object.keys(imageMap).length === 0) {\n    return null;\n  }\n\n  const image = imageMap[variableName] ? imageMap[variableName] : 'player';\n\n  return (\n    <Tooltip\n      interactive\n      title={\n        <div className='tooltip-content'>\n          {images.map((name)=> (\n            <img\n              key={name}\n              alt=''\n              src={require(`../Game/images/${name}.png`)}\n              onClick={()=> onSelect(variableName, name)}\n            />\n          ))}\n        </div>\n      }\n    >\n      <img className='code-sprite'\n        alt=''\n        src={require(`../Game/images/${image}.png`)}\n      />\n    </Tooltip>\n  )\n};\n\nconst mapStateToProps = ({game})=> ({\n  imageMap: game.imageMap,\n  images: game.images\n})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  onSelect: (variableName, imageName)=> {\n    dispatch({\n      type: 'SELECT_IMAGE',\n      variableName,\n      imageName\n    });\n  }\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ImagePicker);\n","import React, {useEffect} from 'react';\nimport {updateCode, compile} from './actions.js';\nimport {connect} from 'react-redux';\nimport Prism from 'prismjs';\nimport {Editor} from 'slate-react';\nimport Plain from 'slate-plain-serializer';\nimport ImagePicker from '../ImagePicker/ImagePicker.js';\n\nconst makeGrammar = ()=> {\n  return {\n    comment: /\\/\\/.*/,\n    variable: {\n      pattern: new RegExp('[^ ]{1} = ([A-Z]+)', 'i'),\n    }\n  }\n}\n\nconst grammar = makeGrammar();\n\nconst onKeyDown = (event, editor, next)=> {\n  if (event.ctrlKey && event.key === 'b') {\n    event.preventDefault()\n    console.log('add bold')\n    editor.addMark('bold')\n  } else {\n    return next()\n  }\n}\n\nconst getContent = (token)=> {\n  if (typeof token == 'string') {\n    return token\n  } else if (typeof token.content == 'string') {\n    return token.content\n  } else {\n    return token.content.map(getContent).join('')\n  }\n}\n\nconst decorateNode = (node, editor, next)=> {\n  const others = next() || []\n  const texts = node.getTexts().toArray()\n  const string = texts.map(t => t.text).join('\\n')\n\n  if (texts.length !== 1) {\n    return others;\n  }\n\n  const tokens = Prism.tokenize(string, grammar)\n  const decorations = []\n  let startText = texts.shift()\n  let endText = startText\n  let startOffset = 0\n  let endOffset = 0\n  let start = 0\n\n  for (const token of tokens) {\n    startText = endText\n    startOffset = endOffset\n\n    const content = getContent(token)\n    const newlines = content.split('\\n').length - 1\n    const length = content.length - newlines\n    const end = start + length\n\n    let available = startText.text.length - startOffset\n    let remaining = length\n\n    endOffset = startOffset + remaining\n\n    while (available < remaining && texts.length > 0) {\n      endText = texts.shift()\n      remaining = length - available\n      available = endText.text.length\n      endOffset = remaining\n    }\n\n    if (typeof token != 'string') {\n      const dec = {\n        anchor: {\n          key: startText.key,\n          offset: startOffset,\n        },\n        focus: {\n          key: endText.key,\n          offset: endOffset,\n        },\n        mark: {\n          type: token.type,\n        },\n      }\n\n      decorations.push(dec)\n    }\n\n    start = end\n  }\n\n  return [...others, ...decorations]\n}\n\nconst renderMark = (props, editor, next, imageMap) => {\n  const { children, attributes, node } = props\n\n  switch (props.mark.type) {\n    case 'variable':\n      const [, right] = node.text.split('=').map((str)=> str.trim())\n      const [firstName,] = right.split(' or ')\n\n      return <span {...attributes}>\n        {children}\n        <ImagePicker variableName={firstName} />\n      </span>\n    case 'comment':\n      return (\n        <span {...attributes} style={{ opacity: '0.33' }}>\n          {children}\n        </span>\n      )\n    case 'keyword':\n      return (\n        <span {...attributes} style={{ fontWeight: 'bold' }}>\n          {children}\n        </span>\n      )\n    default:\n      return next()\n  }\n}\n\nconst Code = ({code, imageMap, onUpdateCode, onCompile})=> {\n  // manually trigger code change on first load\n  useEffect(() => {\n    onCompile(code);\n  }, []);\n\n  return <Editor\n    className={'code'}\n    defaultValue={Plain.deserialize(code)}\n    onChange={onUpdateCode}\n    onKeyDown={onKeyDown}\n    decorateNode={decorateNode}\n    renderMark={(props, editor, next)=> renderMark(props, editor, next, imageMap)}\n  />\n};\n\nconst mapStateToProps = ({code, game})=> ({\n  code: code.code,\n  width: game.width, \n  height: game.height,\n  imageMap: game.imageMap\n})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  onUpdateCode: ({value})=> {\n    dispatch(updateCode(Plain.serialize(value)));\n  },\n  onCompile: (code)=> {\n    dispatch(compile(code));\n  }\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Code);\n","import React from 'react';\nimport './Tile.scss';\n\nconst getPositionStyle = (x, y)=> ({\n  position: 'relative', left: x, top: y\n});\n\nconst Tile = ({x, y, img, onClick})=> (\n  <div className='tile' style={getPositionStyle(x, y)}>\n    <img\n      src={require(`../Game/images/tiles/${img}.png`)}\n      alt=''\n      onClick={()=> onClick()}\n    />\n  </div>\n);\n\nexport default Tile;\n","import React, {useState} from 'react'\nimport {connect} from 'react-redux'\nimport Dialog from '@material-ui/core/Dialog';\nimport Tile from './Tile.js'\nimport {TILE_SIZE} from '../Game/constants.js';\nimport './SpriteEditor.scss';\n\nconst SpritePicker = ({images, tileSets, selectedTileSet, onSelect})=> (\n  <div className='image-list'>\n    {images.map((src, index)=>{\n      return (\n        <img\n          src={src}\n          alt=''\n          className={`image ${index === selectedTileSet && 'selected'}`}\n          onClick={()=> onSelect(index)}\n        />\n      )\n    })}\n  </div>\n)\n\nconst Preview = ({tiles, selectedTile, tileImages, onSelect})=> (\n  <div className='preview'>\n    {tiles.map((rowArr, row)=> (\n      rowArr.map((tileIndex, col)=> (\n        <Tile\n          img={tileImages[tileIndex]}\n          x={col * TILE_SIZE}\n          y={row * TILE_SIZE}\n          onClick={()=> onSelect(row, col, selectedTile)}\n        />\n      ))\n    ))}\n  </div>\n)\n\nconst TilePicker = ({selectedTile, tileImages, onSelect})=> (\n  <div className='picker'>\n    {tileImages.map((name, index)=> (\n      <img\n        key={name}\n        alt=''\n        className={index === selectedTile ? 'selected' : ''}\n        src={require(`../Game/images/tiles/${name}.png`)}\n        onClick={()=> onSelect(index)}\n      />\n    ))}\n  </div>\n)\n\nconst SpriteEditor = ({tileSets, tileImages, images, open, updateTileSets, onClose})=> {  \n  const [selectedTileSet, setSelectedTileSet] = useState(0);\n  const [selectedTile, setSelectedTile] = useState(0);\n  const tiles = tileSets[selectedTileSet]\n\n  return (\n    <Dialog open={open} onClose={onClose}>\n      <div className='container'>\n        <div className='left'>\n          <SpritePicker\n            images={images}\n            tileSets={tileSets}\n            selectedTileSet={selectedTileSet}\n            onSelect={setSelectedTileSet}\n          />\n        </div>\n        <div className='right'>\n          <Preview\n            tiles={tiles}\n            tileImages={tileImages}\n            selectedTile={selectedTile}\n            onSelect={(row, col, newTileIndex)=> {\n              const newTileSets = [...tileSets]\n              newTileSets[selectedTileSet][row][col] = newTileIndex\n              updateTileSets(newTileSets)\n            }}\n          />\n          <TilePicker\n            tileImages={tileImages}\n            selectedTile={selectedTile}\n            onSelect={setSelectedTile}\n          />\n        </div>\n      </div>\n    </Dialog>\n  )\n}\n\nconst mapStateToProps = ({game, spriteEditor})=> ({\n  open: spriteEditor.open,\n  tileImages: spriteEditor.tileImages,\n  images: spriteEditor.images,\n  tileSets: spriteEditor.tileSets\n})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  updateTileSets: (tileSets)=> {\n    dispatch({\n      type: 'spriteEditor/UPDATE_TILESETS',\n      tileSets,\n    })\n  }\n})\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(SpriteEditor)\n","export const examples = {\nsimple_movement: `\n##################\n#                #\n#                #\n#       P        #\n#       #        #\n#      ###       #\n#     #####      #\n#                #\n#                #\n##################\n\nP = Player\n# = Brick\n\n// Accelerate down, like gravity\n{ Player } -> { DOWN Player }\n\n// Move sideways with <LEFT> and <RIGHT> arrow keys\n{ <HORIZONTAL> Player } -> { HORIZONTAL Player }\n`,\nsimple_platformer: `\n##################\n#                #\n#                #\n#                #\n#                #\n#                #\n#     ###?#      #\n#                #\n#    P       G   #\n##################\n\nP = Player\n# = Brick\n? = QuestionBrick\nG = Goomba\n\n// Accelerate down, like gravity\n{ Player } -> { DOWN Player }\n{ Goomba } -> { DOWN Goomba }\n\n// Move sideways with <LEFT> and <RIGHT> arrow keys\n{ <HORIZONTAL> Player } -> { HORIZONTAL Player }\n\n// Jump when <UP> is pressed and when the bottom of Player\n// is touching Wall (Wall = anything)\nDOWN { <UP> Player | Wall } -> { JUMP Player | Wall }\n\n// Player dies if touching Goomba on the side\nHORIZONTAL { Player | Goomba } -> { DEAD Player | Goomba }\n\n// Jumping on top of Goomba kills the Goomba\nDOWN { Player | Goomba } -> { Player | DEAD Goomba }\n\n// Break bricks by head-butting\nUP { Player | Brick } -> { Player | DEAD Brick }\n\n// Head-butting QuestionBrick turns it into another Player\nUP { Player | QuestionBrick } -> { Player | JUMP Player }\n`,\nfour_way_movement: `\n###############\n#             #\n#             #\n#             #\n#      P      #\n#             #\n#             #\n###############\n\nP = Player\n# = Brick\n\n{ <HORIZONTAL> Player } -> { HORIZONTAL Player }\n{ <VERTICAL> Player } -> { VERTICAL Player }\n\n`\n}","import React, {useState, Fragment} from 'react';\nimport {connect} from 'react-redux'\nimport Textarea from 'react-textarea-autosize';\nimport {examples} from './exampleCode';\n\nconst ExamplesModal = ()=> {\n  const [visible, setVisible] = useState(false)\n\n  return visible \n  ?\n    <div className='blanket' onClick={()=> setVisible(false)}>\n      <div className='modal' onClick={(e)=> e.stopPropagation()}>\n        <h1>Examples</h1>\n        {Object.entries(examples).map(([key, value])=> \n          <Fragment key={key}>\n            <h2>{key}</h2>\n            <div className='example'>\n              <Textarea value={value} />\n            </div>\n          </Fragment>\n        )}\n      </div>\n    </div>\n  :\n    <button className='primary' onClick={()=> setVisible(true)}>\n      Examples\n    </button>\n}\n\nconst mapStateToProps = ()=> ({})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  loadPreset: (value)=> {\n    dispatch({type: 'code/LOAD_PRESET', value})\n  }\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ExamplesModal);\n","import React from 'react';\nimport {connect} from 'react-redux'\nimport {HotKeys} from 'react-hotkeys';\n\nimport Game from '../Game/Game.js';\nimport Loop from '../Game/Loop.js';\nimport Code from '../Code/Code.js';\nimport SpriteEditor from '../SpriteEditor/SpriteEditor';\nimport ExamplesModal from '../Examples/ExamplesModal';\nimport {compile, setActive} from '../Code/actions';\nimport {toggleDebug} from '../Game/actions.js';\nimport {setInput, cancelInput, toggleTheme} from './actions.js';\nimport CustomProperties from 'react-custom-properties';\nimport './App.scss';\n\nconst darkColors = {\n  primary: '#F1A0A0',\n  secondary: '#87FFAE',\n  dark: '#000000',\n  light: '#FDF6E2'\n}\n\nconst lightColors = {\n  primary: '#43153F',\n  secondary: '#87FFAE',\n  dark: '#FDF6E2',\n  light: '#FFFFFF'\n}\n\nconst keyMap = {\n  'up': {sequence: 'up', action: 'keydown'},\n  'down': {sequence: 'down', action: 'keydown'},\n  'left': {sequence: 'left', action: 'keydown'},\n  'right': {sequence: 'right', action: 'keydown'},\n  'action1': {sequence: 'x', action: 'keydown'},\n  'action2': {sequence: 'z', action: 'keydown'},\n\n  'cancel_up': {sequence: 'up', action: 'keyup'},\n  'cancel_down': {sequence: 'down', action: 'keyup'},\n  'cancel_left': {sequence: 'left', action: 'keyup'},\n  'cancel_right': {sequence: 'right', action: 'keyup'},\n  'cancel_action1': {sequence: 'x', action: 'keyup'},\n  'cancel_action2': {sequence: 'z', action: 'keyup'},\n};\n\nconst handlers = (onSetInput, onCancelInput, onReset, onRun, onToggleDebug, isGameActive)=> ({\n  'up': ()=> onSetInput('up'),\n  'down': ()=> onSetInput('down'),\n  'left': ()=> onSetInput('left'),\n  'right': ()=> onSetInput('right'),\n  'action1': ()=> onSetInput('action1'),\n  'action2': ()=> onSetInput('action2'),\n  'r': ()=> onReset(),\n  'd': ()=> onToggleDebug(),\n  'space': ()=> onRun(!isGameActive),\n\n  'cancel_up': ()=> onCancelInput('up'),\n  'cancel_down': ()=> onCancelInput('down'),\n  'cancel_left': ()=> onCancelInput('left'),\n  'cancel_right': ()=> onCancelInput('right'),\n  'cancel_action1': ()=> onCancelInput('action1'),\n  'cancel_action2': ()=> onCancelInput('action2'),\n});\n\nconst App = ({\n    code, compile, theme, sprites, imageMap, width, height, debug, error,\n    isGameActive, setGameActive, onToggleDebug, onSetInput, onCancelInput, onToggleTheme,\n    onToggleExamples, onOpenCloseSpriteEditor\n})=> {\n  const colors = theme === 'light' ? lightColors : darkColors;\n  \n  return (\n    <CustomProperties className=\"custom-properties-container\" properties={{\n      '--primary-color': colors.primary,\n      '--secondary-color': colors.secondary,\n      '--dark-color': colors.dark,\n      '--light-color': colors.light,\n      '--hover-color': `${colors.primary}22`  // 22 is is the alpha in hex\n    }}>\n      <div className=\"main\">\n        <div className=\"left\">\n          <header>\n            <h1 className='logo'>micro gg</h1>\n            <ExamplesModal />\n            <button className='primary' onClick={()=> onToggleTheme()}>\n              {theme === 'dark' ? 'light' : 'dark'}\n            </button>\n          </header>\n          <Code imageMap={imageMap} />\n        </div>\n        <HotKeys\n          handlers={handlers(\n            onSetInput,\n            onCancelInput,\n            ()=> compile(code),\n            (active)=> setGameActive(active),\n            ()=> onToggleDebug(),\n            isGameActive\n          )}\n          keyMap={keyMap}\n        >\n          <div className=\"right\">\n            <header>\n              <button className='primary' onClick={()=> compile(code)}>compile</button>\n              <button className='secondary' onClick={()=> setGameActive(!isGameActive)}>\n                {isGameActive ? 'pause' : 'run'}\n              </button>\n              {isGameActive && <Loop />}\n            </header>\n            <div className=\"game-container\">\n              <SpriteEditor\n                onClose={()=> onOpenCloseSpriteEditor(false)}\n              />\n              <Game\n              sprites={sprites}\n              imageMap={imageMap}\n              width={width}\n              height={height}\n              debug={debug}\n              error={error}\n            />\n          </div>\n          </div>\n        </HotKeys>\n      </div>\n    </CustomProperties>\n  );\n};\n\nconst mapStateToProps = ({code, game})=> ({\n  code: code.code,\n  theme: game.theme,\n  isGameActive: game.active,\n  sprites: game.sprites,\n  imageMap: game.imageMap,\n  width: game.width,\n  height: game.height,\n  debug: game.debug,\n  error: game.error\n})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  compile: (code)=> {\n    dispatch(compile(code));\n  },\n  setGameActive: (active)=> {\n    dispatch(setActive(active));\n  },\n  onSetInput: (input)=> {\n    dispatch(setInput(input));\n  },\n  onCancelInput: (input)=> {\n    dispatch(cancelInput(input));\n  },\n  onToggleDebug: ()=> {\n    dispatch(toggleDebug());\n  },\n  onToggleTheme: ()=> {\n    dispatch(toggleTheme());\n  },\n  onToggleExamples: ()=> {\n    dispatch({type: 'app/OPEN_EXAMPLES'})\n  },\n  onOpenCloseSpriteEditor: (open)=> {\n    dispatch({type: 'spriteEditor/SET_OPEN', open: open})\n  }\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(App);\n","\nexport const setInput = (input)=> ({\n  type: 'SET_INPUT',\n  input\n})\n\nexport const cancelInput = (input)=> ({\n  type: 'CANCEL_INPUT',\n  input\n})\n\nexport const toggleTheme = ()=> ({\n  type: 'TOGGLE_THEME'\n})\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {Provider} from 'react-redux'\nimport {createStore} from 'redux'\nimport { persistStore, persistReducer } from 'redux-persist'\nimport { PersistGate } from 'redux-persist/integration/react'\nimport storage from 'redux-persist/lib/storage'\nimport rootReducers from './reducers'\nimport './index.css';\nimport './fonts/FiraCode/fira_code.css';\nimport App from './App/App.js';\n\nconst persistConfig = {\n  key: 'root',\n  storage,\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducers);\n\nconst store = createStore(\n  persistedReducer, /* preloadedState, */\n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n );\n\nconst persistor = persistStore(store);\n// persistor.purge();\n\nReactDOM.render(\n  <Provider store={store}>\n    <PersistGate loading={null} persistor={persistor}>\n      <App />\n    </PersistGate>\n  </Provider>,\n  document.getElementById('root')\n);\n","var map = {\n\t\"./brick.png\": 179,\n\t\"./goomba.png\": 180,\n\t\"./goombared.png\": 181,\n\t\"./no-image.png\": 182,\n\t\"./player.png\": 183,\n\t\"./questionbrick.png\": 184,\n\t\"./spike.png\": 185,\n\t\"./tiles/tile0.png\": 94,\n\t\"./tiles/tile1.png\": 95,\n\t\"./tiles/tile2.png\": 96,\n\t\"./tiles/tile3.png\": 97\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 65;","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAChJREFUWAnt0IEAAAAAw6D5Ux/khVBhwIABAwYMGDBgwIABAwYMvA8MECAAAc4qtccAAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAADZJREFUWAnt0EENAEAIA8HjzOMGi5Bggs/UwDYT2dXvcP+wvWkHCBAgQIAAAQIECBAgQIAAgQGlEANzhaA9CAAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAN1JREFUWAnF0EsOwyAQg2HUi7VH867H6RFT/4tIUZQHkBmwxHb8mVIm5rv8Pq+J/VRrGoD1pSzvaQDW+5UpgHX9NICLRTkZ/gPb9VMALhXFa4b+wH49iKEA94nSbYYBjtYDGQZwlyjcZwjgbD2YIQD3iLKjpAOu1gNKB7hDFJ0lFXC3HlQqwPdFyVXSADXrgaUBfFsU3CUFULseXArAd8XxmoQDWtYDDAf4pjhcm1BA63qQoQDfE0dbEgboWQ80DOBb4mBrQgC968GGAHxHHOvJY8CT9YAfA3xDHOrNH5CJQjHdlUHlAAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAARJJREFUWAljZCASrPp/le0ew23H/wz//RgZGLT+MzBIMTD8B2IGHiKNwKoMaBZ+0PV/q8Q/hl91QAujgRby4VdNuixOB0z6v439K8PPaqCCIqCvuUk3mjgdWB0A8fXP9UBfWxBnDPmqMBzQ/X+j3l+Gv1uBlsuQbyzxOlEcAPX5aXpZDnImE8ytoDj/xwAOdrr4HGYvC4wBSnBANs3jHGYfjAZHATSr3aFlaodZiE6DowCSz2mX1dAtReYzgUo4SCGDLEw/NhOoeKVFCUesF5hAZTuximmhjgmYCrVoYTCxZgJDAFSrDRwA5gJwlTpgLgBlQ4rqc0pdDi+KKTWIXP2jDhgNgdEQGA2B0RAYDYHREAAA23dKamEoqhoAAAAASUVORK5CYII=\""],"sourceRoot":""}